import json, time, random, queue, threading, base64
from typing import List, Dict, Optional
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
from tkinter.scrolledtext import ScrolledText
import requests, cloudscraper
import binascii
import struct
import zlib
import os
import sys
import random
import uuid
import urllib.parse
import threading
from concurrent.futures import ThreadPoolExecutor
from PIL import Image, ImageTk
from auth import login
from ugc  import load_ugcs, loveit

def resource_path(relative_path):
    base_path = getattr(sys, '_MEIPASS', os.path.abspath(os.path.dirname(__file__)))
    return os.path.join(base_path, relative_path)

# --- kleiner, animierter ToggleSwitch (Canvas) ---
class AnimatedToggleSwitch(ttk.Frame):
    def __init__(self, master, value=False, on_toggle=None, width=44, height=24):
        super().__init__(master)
        self.on_toggle = on_toggle
        self.w = width
        self.h = height
        self.pad = 2
        self._is_on = bool(value)
        self._animating = False

        self.canvas = tk.Canvas(self, width=self.w, height=self.h, highlightthickness=0, bg=self._bg())
        self.canvas.pack()
        self.canvas.bind("<Button-1>", self._click)

        # IDs
        self._track_id = None
        self._knob_id  = None
        self._draw_static()
        self._place_knob(instant=True)

    def set(self, value: bool, trigger: bool = True):
        """Extern Status setzen (ohne Animation)."""
        self._is_on = bool(value)
        self._place_knob(instant=True)
        if trigger and self.on_toggle:
            self.on_toggle(self._is_on)

    def _bg(self):
        """Hintergrundfarbe robust ermitteln (ttk-sicher)."""
        try:
            return self.master.cget("background")
        except Exception:
            pass
        try:
            style = ttk.Style()
            try:
                style_name = self.master.cget("style") or ""
            except Exception:
                style_name = ""
            candidates = [style_name, self.master.winfo_class(), "TFrame", "TLabelframe"]
            for name in candidates:
                if not name:
                    continue
                col = style.lookup(name, "background")
                if col:
                    return col
        except Exception:
            pass
        return "#FFFFFF"

    def _draw_static(self):
        self.canvas.delete("all")
        radius = self.h / 2
        fill = "#22c55e" if self._is_on else "#4b5563"
        self._track_id = self._round_rect(self.pad, self.pad, self.w - self.pad, self.h - self.pad,
                                          radius - 2, fill=fill, outline="")
        size = self.h - 2 * self.pad
        self._knob_id = self.canvas.create_oval(self.pad, self.pad, self.pad + size, self.pad + size,
                                                fill="#FFFFFF", outline="")

    def _round_rect(self, x1, y1, x2, y2, r, **kwargs):
        points = [
            x1 + r, y1, x2 - r, y1,
            x2, y1, x2, y1 + r,
            x2, y2 - r, x2, y2,
            x2 - r, y2, x1 + r, y2,
            x1, y2, x1, y2 - r,
            x1, y1 + r, x1, y1,
        ]
        return self.canvas.create_polygon(points, smooth=True, **kwargs)

    def _click(self, _evt=None):
        if self._animating:
            return
        target = not self._is_on
        self._animate_to(target)

    def _place_knob(self, instant=False):
        size = self.h - 2 * self.pad
        left_x  = self.pad
        right_x = self.w - self.pad - size
        x = right_x if self._is_on else left_x
        self.canvas.coords(self._knob_id, x, self.pad, x + size, self.pad + size)
        self.canvas.itemconfig(self._track_id, fill="#22c55e" if self._is_on else "#4b5563")

    def _animate_to(self, target_on: bool):
        """Animiert zum Zielzustand und ruft den Callback NACH der Animation auf."""
        if target_on == self._is_on:
            # Nichts zu tun
            self._place_knob(instant=True)
            return

        self._animating = True
        steps = 8
        dur_ms = 90

        size = self.h - 2 * self.pad
        left_x  = self.pad
        right_x = self.w - self.pad - size

        # Start/Ziel
        coords = self.canvas.coords(self._knob_id)
        x_now = coords[0] if coords else (right_x if self._is_on else left_x)
        x_end = right_x if target_on else left_x
        delta = (x_end - x_now) / steps if steps else 0

        # Farbverlauf
        def hex_to_rgb(h):
            h = h.lstrip("#")
            return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))
        def rgb_to_hex(t):
            return f"#{t[0]:02x}{t[1]:02x}{t[2]:02x}"
        def lerp(a, b, t): return int(a + (b - a) * t)

        start_col = hex_to_rgb(self.canvas.itemcget(self._track_id, "fill") or ("#22c55e" if self._is_on else "#4b5563"))
        end_col   = hex_to_rgb("#22c55e" if target_on else "#4b5563")

        def step(i=0, x=x_now):
            t = i / steps if steps else 1
            r = lerp(start_col[0], end_col[0], t)
            g = lerp(start_col[1], end_col[1], t)
            b = lerp(start_col[2], end_col[2], t)
            self.canvas.itemconfig(self._track_id, fill=rgb_to_hex((r, g, b)))
            self.canvas.coords(self._knob_id, x, self.pad, x + size, self.pad + size)
            if i < steps:
                self.after(max(1, dur_ms // steps), step, i + 1, x + delta)
            else:
                # Ziel fixieren & Status übernehmen
                self._is_on = target_on
                self._place_knob(instant=True)
                self._animating = False
                if self.on_toggle:
                    # Callback erst am Ende ausführen
                    try:
                        self.on_toggle(self._is_on)
                    except Exception:
                        pass

        step()


# -------------------- Style (dark blue) --------------------
def setup_style(root: tk.Tk):
    style = ttk.Style(root)
    style.theme_use("clam")

    # Schwarz-Rot-Farbschema
    bg  = "#000000"   # tiefes Schwarz
    fg  = "#ffffff"   # Weiß für Text
    acc = "#941515"   # kräftiges Rot
    hl  = "#000000"   # dunkles Grau

    root.configure(bg=bg)
    style.configure(".", background=bg, foreground=fg, font=("Comic Sans MS", 10))
    style.configure("TFrame", background=bg)
    style.configure("TLabel", background=bg, foreground=fg)
    style.configure("TLabelFrame", background=bg, foreground=acc, font=("Comic Sans MS", 10, "bold"))
    style.configure("TButton", padding=6, relief="flat", background=acc, foreground="white")
    style.map("TButton", background=[("active", "#941515")])
    style.configure("TEntry", fieldbackground="#000000", foreground=fg, insertcolor=fg)
    style.configure("TNotebook", background=bg)
    style.configure("TNotebook.Tab", background=hl, foreground=fg, padding=(12, 6))
    style.map("TNotebook.Tab", background=[("selected", acc)], foreground=[("selected", "white")])


# -------------------- Shared Tokens -----------------------
shared_tokens: List[Dict] = []


# -------------------- LoveIt Tab --------------------------
class LoveItTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.ugcs: List[Dict] = []
        self.log_q, self.prog_q = queue.Queue(), queue.Queue()
        self._build(); self._poll()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login"); lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w"); 
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w"); 
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w"); 
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0,"DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3,columnspan=2,pady=pad)

        self.tok_var = tk.StringVar(value="Tokens: 0")
        ttk.Label(lf, textvariable=self.tok_var).grid(row=4,columnspan=2)

        tf = ttk.Frame(self); tf.pack(fill="x", padx=pad)
        ttk.Button(tf, text="Load tokens.json", command=self.load_tokens).pack(side="left", padx=pad)

        ugcf = ttk.LabelFrame(self, text="UGCs"); ugcf.pack(fill="both",expand=True,padx=pad,pady=pad)
        self.lb = tk.Listbox(ugcf, selectmode=tk.MULTIPLE, bg="#000000", fg="#ffffff")
        self.lb.pack(side="left",fill="both",expand=True)
        sb  = ttk.Scrollbar(ugcf, command=self.lb.yview); sb.pack(side="right",fill="y")
        self.lb.config(yscrollcommand=sb.set)

        cf = ttk.LabelFrame(self, text="➕ Custom ID"); cf.pack(fill="x", padx=pad)
        self.e_custom = ttk.Entry(cf); self.e_custom.pack(side="left",fill="x",expand=True,padx=pad)
        ttk.Button(cf, text="Add", command=self.add_custom).pack(side="right",padx=pad)

        bf = ttk.Frame(self); bf.pack(fill="x",padx=pad,pady=pad)
        self.btn_load = ttk.Button(bf,text="Load UGCs (first token)",command=self.load_ugcs); self.btn_load.pack(side="left",padx=pad)
        self.btn_love = ttk.Button(bf,text="Send LoveIt",state="disabled",command=self.start_worker); self.btn_love.pack(side="left",padx=pad)

        self.prog = ttk.Progressbar(self,maximum=100); self.prog.pack(fill="x",padx=pad)
        self.log  = ScrolledText(self, height=8, state="disabled", bg="#000000", fg="#ffffff", insertbackground="#ffffff")
        self.log.pack(fill="both",expand=True,padx=pad,pady=pad)

    def login_click(self):
        u,p,c = self.e_user.get().strip(), self.e_pw.get().strip(), self.e_cty.get().strip().upper()
        if not all([u,p,c]): return messagebox.showwarning("Input","Missing fields")
        try:
            info = login(u,p,c)
            shared_tokens.append(info); self.tok_var.set(f"Tokens: {len(shared_tokens)}")
            messagebox.showinfo("Login","Token saved")
        except Exception as e:
            messagebox.showerror("Login",str(e))

    def load_tokens(self):
        fp = filedialog.askopenfilename(title="tokens.json",filetypes=[("JSON","*.json")])
        if fp:
            try:
                data=json.load(open(fp,encoding="utf-8"))
                if isinstance(data,list):
                    shared_tokens.extend(data); self.tok_var.set(f"Tokens: {len(shared_tokens)}")
            except Exception as e:
                messagebox.showerror("tokens.json", str(e))

    def load_ugcs(self):
        if not shared_tokens: return
        tok=shared_tokens[0]
        try:
            self.ugcs=load_ugcs(tok["access_token"],tok["profile_id"])
        except Exception as e:
            return messagebox.showerror("UGCs",str(e))
        self.lb.delete(0,tk.END); [self.lb.insert(tk.END,f"{u['id']} | {u.get('title','')}") for u in self.ugcs]
        self.btn_love["state"]="normal"

    def add_custom(self):
        ids=[i for i in self.e_custom.get().replace(",", " ").split() if i]
        self.e_custom.delete(0,tk.END)
        for i in ids:
            if not any(u["id"]==i for u in self.ugcs):
                self.ugcs.append({"id":i}); self.lb.insert(tk.END,f"{i} | Custom")

    def start_worker(self):
        sel=[self.ugcs[i] for i in self.lb.curselection()]
        if not sel: return
        total=len(sel)*len(shared_tokens)
        self.prog.config(maximum=total,value=0)
        self.log.config(state="normal"); self.log.delete("1.0",tk.END); self.log.config(state="disabled")
        self.btn_love["state"]="disabled"
        threading.Thread(target=self.worker,args=(sel,total),daemon=True).start()

    def worker(self,sel,total):
        done=0
        for tok in shared_tokens:
            for u in sel:
                ok=loveit(tok["access_token"],tok["profile_id"],u["id"])
                self.log_q.put(f"[{'OK' if ok else 'FAIL'}] {u['id']}"); done+=1; self.prog_q.put(done)
        self.log_q.put("Finished"); self.prog_q.put(-1)

    def _poll(self):
        while not self.log_q.empty(): self._append(self.log_q.get())
        while not self.prog_q.empty():
            v=self.prog_q.get()
            if v==-1: self.btn_love["state"]="normal"
            else: self.prog["value"]=v
        self.after(100,self._poll)

    def _append(self,txt):
        self.log.config(state="normal"); self.log.insert(tk.END,txt+"\n"); self.log.see(tk.END); self.log.config(state="disabled")

# -------------------- Token Runner Tab --------------------
class TokenRunnerTab(ttk.Frame):
    LOGIN_URL    = "https://eu-secure.mspapis.com/loginidentity/connect/token"
    ACCOUNTS_FILE = "token.txt"     # <- LOKALE Datei mit user:pass:country
    PROXIES_FILE  = "proxies.txt"   # <- LOKALE Datei mit user:pass@host:port

    def __init__(self, master):
        super().__init__(master)
        self.running = False
        self.success = 0

        # Round-robin Proxies
        self.proxies = []
        self.proxy_idx = 0
        self.proxy_lock = threading.Lock()

        self.thread_count = tk.IntVar(value=3)
        self.delay_seconds = tk.IntVar(value=3)

        self._build()
        self._load_proxies()
        self._load_accounts()

    # ---------- UI ----------
    def _build(self):
        pad = 6

        top = ttk.Frame(self)
        top.pack(fill="x", padx=pad, pady=pad)

        self.btn = ttk.Button(top, text="Start", command=self.toggle)
        self.btn.pack(side="left", padx=pad)

        ttk.Button(top, text="🔄 Proxies neu laden", command=self._load_proxies).pack(side="left", padx=pad)
        ttk.Button(top, text="📄 Accounts neu laden", command=self._load_accounts).pack(side="left", padx=pad)
        ttk.Button(top, text="Manual", command=self.manual_win).pack(side="left", padx=pad)

        self.lbl = ttk.Label(self, text="OK Tokens: 0", foreground="lightgreen")
        self.lbl.pack()

        tf = ttk.Frame(self)
        tf.pack(fill="x", padx=pad)

        ttk.Label(tf, text="Threads:").pack(side="left", padx=pad)
        ttk.Spinbox(tf, from_=1, to=50, textvariable=self.thread_count, width=5).pack(side="left")

        ttk.Label(tf, text="Delay (s):").pack(side="left", padx=pad)
        ttk.Spinbox(tf, from_=0, to=10, textvariable=self.delay_seconds, width=5).pack(side="left")

        self.log = ScrolledText(self, height=15, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

        # kleine Statuslabels
        stat = ttk.Frame(self); stat.pack(fill="x", padx=pad, pady=(0, pad))
        self.acc_count_var = tk.StringVar(value="Accounts: 0")
        self.prx_count_var = tk.StringVar(value="Proxies: 0")
        ttk.Label(stat, textvariable=self.acc_count_var).pack(side="left")
        ttk.Label(stat, textvariable=self.prx_count_var).pack(side="left", padx=12)

    # ---------- Logging ----------
    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

    def inc_ok(self):
        self.success += 1
        self.lbl.config(text=f"OK Tokens: {self.success}")

    # ---------- Daten laden ----------
    def _base_dir(self):
        return os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)

    def _load_proxies(self):
        path = os.path.join(self._base_dir(), self.PROXIES_FILE)
        self.proxies.clear()
        try:
            with open(path, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue
                    # Erwartetes Format: user:pass@host:port (dein Beispiel)
                    # z.B. user-NiveDev:Pwd@eu.lunaproxy.com:12233
                    if "@" in line and ":" in line:
                        # baue http(s) Proxy-URL
                        proxy_url = f"http://{line}"
                        self.proxies.append({"http": proxy_url, "https": proxy_url})
            self.prx_count_var.set(f"Proxies: {len(self.proxies)}")
            self.write(f"[proxies] geladen: {len(self.proxies)}", "cyan")
        except Exception as e:
            self.write(f"[proxies] Fehler beim Laden: {e}", "red")
            self.prx_count_var.set("Proxies: 0")

    def _load_accounts(self):
        self.accounts = []  # Liste von Tupeln (user, pass, country)
        path = os.path.join(self._base_dir(), self.ACCOUNTS_FILE)
        try:
            with open(path, "r", encoding="utf-8") as f:
                for line in f:
                    l = line.strip()
                    if not l or l.startswith("#"):
                        continue
                    parts = l.split(":")
                    if len(parts) == 1:
                        # nur username -> kein pass, skip
                        continue
                    if len(parts) == 2:
                        user, pw = parts
                        ctry = "de"
                    else:
                        user, pw, ctry = parts[0], parts[1], (parts[2] or "de")
                    self.accounts.append((user.strip(), pw.strip(), ctry.strip().lower()))
            self.acc_count_var.set(f"Accounts: {len(self.accounts)}")
            self.write(f"[accounts] geladen: {len(self.accounts)}", "cyan")
        except FileNotFoundError:
            self.write(f"[accounts] {self.ACCOUNTS_FILE} nicht gefunden", "red")
            self.acc_count_var.set("Accounts: 0")
        except Exception as e:
            self.write(f"[accounts] Fehler beim Laden: {e}", "red")
            self.acc_count_var.set("Accounts: 0")

    # ---------- Proxy RR ----------
    def _next_proxy(self):
        if not self.proxies:
            return None
        with self.proxy_lock:
            prx = self.proxies[self.proxy_idx % len(self.proxies)]
            self.proxy_idx += 1
            return prx

    # ---------- Worker ----------
    def worker(self, q: queue.Queue):
        timeout_streak = 0
        while self.running:
            try:
                u, p, c = q.get_nowait()
            except queue.Empty:
                break

            try:
                prx = self._next_proxy()
                info = login(u, p, c, proxies=prx)  # dein vorhandenes login() nutzt proxies=
                shared_tokens.append(info)
                self.write(f"[OK] {u}", "green")
                self.inc_ok()
                timeout_streak = 0
                time.sleep(self.delay_seconds.get())
            except requests.exceptions.Timeout:
                timeout_streak += 1
                self.write(f"[TIMEOUT] {u}", "orange")
                if timeout_streak >= 7:
                    self.write("[INFO] 7x Timeout → Warte 30 Sekunden...", "yellow")
                    time.sleep(120)
                    timeout_streak = 0
            except Exception as e:
                self.write(f"[FAIL] {u} ({e})", "red")
                timeout_streak = 0

            q.task_done()

    # ---------- Start/Stop ----------
    def toggle(self):
        self.running = not self.running
        self.btn.config(text="Stop" if self.running else "Start")
        if not self.running:
            return

        if not getattr(self, "accounts", None):
            self._load_accounts()
        if not self.accounts:
            self.write("[WARN] Keine Accounts geladen.", "yellow")
            self.running = False
            self.btn.config(text="Start")
            return

        q = queue.Queue()
        for a in self.accounts:
            q.put(a)

        for _ in range(self.thread_count.get()):
            threading.Thread(target=self.worker, args=(q,), daemon=True).start()

    # ---------- Manual Login ----------
    def manual_win(self):
        w = tk.Toplevel(self)
        w.title("Manual")
        w.geometry("260x200")

        ttk.Label(w, text="User").pack()
        e_u = ttk.Entry(w); e_u.pack()

        ttk.Label(w, text="Pass").pack()
        e_p = ttk.Entry(w, show="*"); e_p.pack()

        ttk.Label(w, text="Country").pack()
        e_c = ttk.Entry(w); e_c.insert(0, "de"); e_c.pack()

        def run():
            try:
                prx = self._next_proxy()
                info = login(e_u.get(), e_p.get(), e_c.get(), proxies=prx)
                shared_tokens.append(info)
                self.write("[OK] manual", "green")
                self.inc_ok()
            except Exception as e:
                self.write(f"[FAIL] manual ({e})", "red")
            w.destroy()

        ttk.Button(w, text="Login", command=run).pack(pady=8)

# -------------------- Gender Switch Tab --------------------
class GenderSwitchTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.token_info = None
        self.scraper = cloudscraper.create_scraper()
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login"); lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0,"DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        self.gender_var = tk.StringVar(value="Geschlecht: Unbekannt")
        ttk.Label(self, textvariable=self.gender_var).pack(pady=pad)

        ttk.Button(self, text="🔄 Geschlecht wechseln", command=self.toggle_gender).pack(pady=pad)

        self.log = ScrolledText(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausfüllen!")

        try:
            self.token_info = login(u, p, c)  # liefert access_token + profile_id
            gender = self.get_gender()
            self.gender_var.set(f"Geschlecht: {gender}")
            self.write(f"[OK] Eingeloggt als {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def get_gender(self):
        url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{self.token_info['profile_id']}/games/j68d/attributes"
        headers = {
            "Authorization": f"Bearer {self.token_info['access_token']}",
            "Accept": "application/json"
        }
        r = self.scraper.get(url, headers=headers)
        r.raise_for_status()
        data = r.json()
        return data.get("additionalData", {}).get("Gender", "Unbekannt")

    def toggle_gender(self):
        if not self.token_info:
            return messagebox.showwarning("Nicht eingeloggt", "Bitte zuerst einloggen.")

        try:
            url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{self.token_info['profile_id']}/games/j68d/attributes"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Accept": "application/json"
            }

            # Aktuellen Status abrufen
            r = self.scraper.get(url, headers=headers)
            r.raise_for_status()
            data = r.json()

            current_gender = data["additionalData"].get("Gender", "Boy")
            new_gender = "Girl" if current_gender == "Boy" else "Boy"
            data["additionalData"]["Gender"] = new_gender

            headers["Content-Type"] = "application/json"
            put = self.scraper.put(url, headers=headers, json=data)
            put.raise_for_status()

            self.gender_var.set(f"Geschlecht: {new_gender}")
            self.write(f"[OK] Geschlecht geändert zu {new_gender}", "green")
            self.write(f"Logge dich neu ein!", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Fehler", str(e))

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

# -------------------- Autograph Tab --------------------
class AutographTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.accounts = []
        self.scraper = cloudscraper.create_scraper()
        self.auto_running = False
        self.auto_thread = None
        self._build()
        self._start_token_refresh_thread()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf)
        self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*")
        self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf)
        self.e_cty.insert(0, "DE")
        self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)
        ttk.Button(lf, text="📜 ListeLogin", command=lambda: self.login_from_file("autograph.txt")).grid(row=4, columnspan=2, pady=(0, pad))
        ttk.Button(lf, text="📜 ListeLogin2", command=lambda: self.login_from_file("autograph2.txt")).grid(row=5, columnspan=2, pady=(0, pad))

        self.account_list = tk.Listbox(self, height=4, bg="#000000", fg="white", selectbackground="#000000", selectforeground="white")
        self.account_list.pack(fill="x", padx=pad, pady=(pad, 0))

        ttk.Button(self, text="❌ Entfernen", command=self.remove_selected_account).pack(pady=(0, pad))

        targetf = ttk.LabelFrame(self, text="Autogramm senden an:")
        targetf.pack(fill="x", padx=pad, pady=pad)

        self.e_target = ttk.Entry(targetf)
        self.e_target.pack(fill="x", padx=pad, pady=pad)

        ttk.Button(self, text="▶️ Start", command=self.start_auto).pack(pady=pad)
        ttk.Button(self, text="⏹️ Stop", command=self.stop_auto).pack(pady=(0, pad))

        self.log = ScrolledText(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_from_file(self, filename):
        try:
            base_dir = os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)
            full_path = os.path.join(base_dir, filename)
            self.write(f"[DEBUG] Suche Datei: {full_path}", "yellow")

            with open(full_path, "r", encoding="utf-8") as f:
                lines = f.readlines()

            for line in lines:
                parts = line.strip().split(":")
                if len(parts) < 2:
                    continue
                u = parts[0].strip()
                p = parts[1].strip()
                c = parts[2].strip().upper() if len(parts) > 2 else "DE"
                try:
                    token_info = login(u, p, c)
                    token_info["username"] = u
                    token_info["password"] = p
                    token_info["country"] = c
                    self.accounts.append(token_info)
                    self.account_list.insert(tk.END, u)
                    self.write(f"[OK] Eingeloggt als {u}", "green")
                except Exception as e:
                    self.write(f"[FEHLER] {u}: {e}", "red")

        except Exception as e:
            self.write(f"[FEHLER] Datei konnte nicht gelesen werden: {e}", "red")

    def remove_selected_account(self):
        selected = self.account_list.curselection()
        if not selected:
            return
        index = selected[0]
        acc = self.accounts[index]
        self.write(f"[INFO] Account entfernt: {acc['username']}", "yellow")
        self.account_list.delete(index)
        del self.accounts[index]

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        if int(self.log.index("end-1c").split(".")[0]) > 50:
            self.log.delete("1.0", "2.0")
        self.log.see(tk.END)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausfüllen!")
        try:
            token_info = login(u, p, c)
            token_info["username"] = u
            token_info["password"] = p
            token_info["country"] = c
            self.accounts.append(token_info)
            self.account_list.insert(tk.END, u)
            self.write(f"[OK] Eingeloggt als {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def find_profile_id(self, username, region):
        try:
            url = "https://eu.mspapis.com/edgerelationships/graphql/graphql"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Content-Type": "application/json"
            }
            query = """
            query GetProfileSearch($region: String!, $startsWith: String!, $pageSize: Int, $currentPage: Int, $preferredGameId: String!) {
                findProfiles(region: $region, nameBeginsWith: $startsWith, pageSize: $pageSize, page: $currentPage) {
                    totalCount
                    nodes {
                        id
                        avatar(preferredGameId: $preferredGameId) {
                            gameId
                            face
                            full
                        }
                    }
                }
            }
            """
            variables = {
                "region": region,
                "startsWith": username,
                "pageSize": 50,
                "currentPage": 1,
                "preferredGameId": "j68d"
            }
            payload = {"query": query, "variables": variables}
            r = self.scraper.post(url, headers=headers, json=payload)
            r.raise_for_status()
            data = r.json()
            nodes = data.get("data", {}).get("findProfiles", {}).get("nodes", [])
            if not nodes:
                self.write(f"[FEHLER] Kein Profil mit dem Namen '{username}' gefunden.", "red")
                return None
            return nodes[0]["id"]
        except Exception as e:
            self.write(f"[FEHLER] Profil-ID konnte nicht ermittelt werden: {e}", "red")
            return None

    def send_autograph(self, token_info, receiver_id, target_name):
        try:
            url = "https://eu.mspapis.com/federationgateway/graphql"
            headers = {
                "Authorization": f"Bearer {token_info['access_token']}",
                "Content-Type": "application/json"
            }
            payload = {
                "id": "SendGreetings-159BDD7706D824BB8F14874A7FAE3368",
                "variables": {
                    "greetingType": "Autograph",
                    "receiverProfileId": receiver_id,
                    "ignoreDailyCap": False
                }
            }
            r = self.scraper.post(url, headers=headers, json=payload)
            r.raise_for_status()
            data = r.json()
            success = data.get("data", {}).get("greetings", {}).get("sendGreeting", {}).get("success", False)
            if success:
                self.write(f"[OK] Autogramm an {target_name} gesendet von {token_info['username']}", "green")
            else:
                self.write(f"[FEHLER] Autogramm von {token_info['username']} konnte nicht gesendet werden", "red")
        except Exception as e:
            self.write(f"[FEHLER] {token_info['username']}: {e}", "red")

    def start_auto(self):
        if not self.accounts:
            return messagebox.showwarning("Keine Accounts", "Bitte mindestens einen Account anmelden.")
        if not self.e_target.get().strip():
            return messagebox.showwarning("Fehler", "Zielbenutzer eingeben!")

        self.auto_running = True
        self.auto_thread = threading.Thread(target=self.auto_loop, daemon=True)
        self.auto_thread.start()
        self.write("[INFO] Automatisches Versenden gestartet...", "green")

    def stop_auto(self):
        self.auto_running = False
        self.write("[INFO] Automatisches Versenden gestoppt.", "yellow")

    def auto_loop(self):
        while self.auto_running:
            target_name = self.e_target.get().strip()
            if not target_name:
                self.write("[FEHLER] Kein Zielbenutzer gesetzt.", "red")
                break
            for acc in self.accounts:
                self.token_info = acc
                profile_id = self.find_profile_id(target_name, acc["country"])
                if profile_id:
                    self.send_autograph(acc, profile_id, target_name)
                time.sleep(1)
            for _ in range(120):
                if not self.auto_running:
                    break
                time.sleep(1)

    def _start_token_refresh_thread(self):
        def refresh_loop():
            while True:
                time.sleep(3600)
                for i, acc in enumerate(self.accounts):
                    try:
                        new_token = login(acc["username"], acc["password"], acc["country"])
                        new_token["username"] = acc["username"]
                        new_token["password"] = acc["password"]
                        new_token["country"] = acc["country"]
                        self.accounts[i] = new_token
                        self.write(f"[REFRESH] Token erneuert für {acc['username']}", "cyan")
                    except Exception as e:
                        self.write(f"[FEHLER] Token-Erneuerung fehlgeschlagen für {acc['username']}: {e}", "red")
        threading.Thread(target=refresh_loop, daemon=True).start()

# -------------------- Duplication --------------------
class GiftOpenerTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.accounts = []
        self.threads = []
        self.start_event = threading.Event()
        self._build()

    def _build(self):
        pad = 6

        lf = ttk.LabelFrame(self, text="Logins einzeln")
        lf.pack(fill="x", padx=pad, pady=pad)

        for i in range(2):
            ttk.Label(lf, text=f"Benutzer {i+1}").grid(row=i*4, column=0, sticky="w")
            setattr(self, f"e_user{i}", ttk.Entry(lf))
            getattr(self, f"e_user{i}").grid(row=i*4, column=1, padx=pad)

            ttk.Label(lf, text="Passwort").grid(row=i*4+1, column=0, sticky="w")
            setattr(self, f"e_pw{i}", ttk.Entry(lf, show="*"))
            getattr(self, f"e_pw{i}").grid(row=i*4+1, column=1, padx=pad)

            ttk.Label(lf, text="Land").grid(row=i*4+2, column=0, sticky="w")
            e_cty = ttk.Entry(lf); e_cty.insert(0, "DE")
            setattr(self, f"e_cty{i}", e_cty)
            e_cty.grid(row=i*4+2, column=1, padx=pad)

            ttk.Button(lf, text=f"Login Benutzer {i+1}", command=lambda idx=i: self.login_click(idx)).grid(row=i*4+3, columnspan=2, pady=pad)

        gf = ttk.LabelFrame(self, text="🎁 Geschenk öffnen")
        gf.pack(fill="x", padx=pad, pady=pad)

        for i in range(2):
            ttk.Label(gf, text=f"Gift-ID für Benutzer {i+1}").grid(row=i, column=0)
            setattr(self, f"e_gift{i}", ttk.Entry(gf))
            getattr(self, f"e_gift{i}").grid(row=i, column=1, padx=pad)

        ttk.Button(self, text="🧠 Threads vorbereiten", command=self.open_gifts).pack(pady=pad)
        ttk.Button(self, text="🎯 Jetzt starten", command=self.start_event.set).pack(pady=pad)

        self.log = tk.Text(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self, idx):
        u = getattr(self, f"e_user{idx}").get().strip()
        p = getattr(self, f"e_pw{idx}").get().strip()
        c = getattr(self, f"e_cty{idx}").get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausfüllen!")

        try:
            for i in range(2):  # doppelt einloggen
                token_info = login(u, p, c)
                token_info["username"] = u
                token_info["country"] = c
                self.accounts.append(token_info)
            self.write(f"[OK] Benutzer {idx+1} doppelt eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login Benutzer {idx+1}: {e}", "red")
            messagebox.showerror("Login", str(e))

    def open_gifts(self):
        self.threads.clear()
        self.start_event.clear()

        for idx in range(len(self.accounts)):
            for _ in range(35):  # volle Power für jede Session
                t = threading.Thread(target=self.open_single_gift, args=(idx,), daemon=True)
                self.threads.append(t)

        for t in self.threads:
            t.start()

        self.write("[INFO] Alle Threads bereit. Warte auf Startsignal...", "yellow")

    def open_single_gift(self, idx):
        acc = self.accounts[idx]
        if not acc:
            self.write(f"[FEHLER] Benutzer {idx+1} nicht eingeloggt", "red")
            return

        gift_id_index = 0 if idx < 2 else idx % 2
        gift_id = getattr(self, f"e_gift{gift_id_index}").get().strip()
        if not gift_id:
            self.write(f"[FEHLER] Keine Gift-ID für Benutzer {gift_id_index+1} angegeben", "red")
            return

        self.start_event.wait()  # Synchronstart für alle Threads

        payload = {
            "query": """
            mutation OpenGift($giftId: ID!, $receiverProfileId: ID!) {
                openGift(input: {
                    giftId: $giftId,
                    receiverProfileId: $receiverProfileId
                }) {
                    success
                    error
                    item {
                        id
                        objectId
                        objectSource
                        additionalData
                        tags {
                            id
                            source
                        }
                    }
                }
            }
            """,
            "variables": {
                "giftId": gift_id,
                "receiverProfileId": acc["profile_id"]
            }
        }

        headers = {
            "Authorization": f"Bearer {acc['access_token']}",
            "Content-Type": "application/json",
            "Referer": "https://moviestarplanet2.com/",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36"
        }

        try:
            res = self.scraper.post(
                "https://eu.mspapis.com/edgegifts/graphql/graphql",
                headers=headers,
                json=payload,
                timeout=6  # aggressiver Timeout
            )
            res.raise_for_status()
            data = res.json()["data"]["openGift"]
            if data["success"]:
                item_id = data["item"]["id"]
                self.after(0, self.write, f"[OK] Geschenk {gift_id} geöffnet für {acc['username']} (Item ID: {item_id})", "green")
            else:
                error = data["error"]
                self.after(0, self.write, f"[FEHLER] Geschenk nicht geöffnet für {acc['username']}: {error}", "red")
        except Exception as e:
            self.after(0, self.write, f"[FEHLER] Fehler bei {acc['username']}: {e}", "red")

    def write(self, msg, color=None):
        self.log.insert(tk.END, msg + "\n")
        self.log.see(tk.END)


# -------------------- Daily Login --------------------
class DailyLogin(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.accounts = []
        self._build()

    def _build(self):
        pad = 6

        ttk.Label(self, text="📄 Accountliste auswählen").pack(pady=(8, 2))
        self.combo_claim = ttk.Combobox(
            self, values=["1", "2", "3", "4", "5", "6", "7"], state="readonly", width=5)
        self.combo_claim.set("1")
        self.combo_claim.pack()

        ttk.Button(self, text="📜 Liste einloggen", command=self.login_from_file).pack(pady=(4, pad))

        self.log = tk.Text(self, height=16, bg="#000000", fg="white", insertbackground="#ffffff")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_from_file(self):
        file_id = self.combo_claim.get()
        suffix = '' if file_id == '1' else file_id
        dateiname = resource_path(f"kokosnuss{suffix}.txt")

        # → holt den Pfad der EXE oder des Skripts
        base_dir = os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)
        dateiname = os.path.join(base_dir, f"kokosnuss{suffix}.txt")

        # 👇 Debug-Ausgabe für den gesuchten Dateipfad
        self.write(f"[DEBUG] Suche Datei: {dateiname}", "yellow")

        def worker():
            try:
                with open(dateiname, "r", encoding="utf-8") as f:
                    lines = [line.strip() for line in f if line.strip()]
                for line in lines:
                    parts = line.split(":")
                    if len(parts) < 2:
                        continue
                    u, p = parts[0], parts[1]
                    c = parts[2] if len(parts) >= 3 else "DE"
                    try:
                        scraper = cloudscraper.create_scraper()
                        token_info = login(u, p, c, proxies=scraper.proxies)
                        token_info["username"] = u
                        self.accounts.append(token_info)
                        self.write(f"[Login] {u}", "green")
                    except Exception as e:
                        self.write(f"[FEHLER] {u}: {e}", "red")
                    time.sleep(0.5)
                self.write("✅ Liste abgeschlossen. Weitere Liste nur manuell starten.", "cyan")
            except Exception as e:
                self.write(f"[FEHLER] Datei: {e}", "red")

        threading.Thread(target=worker, daemon=True).start()

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_configure(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)


# -------------------- Teleport Tab --------------------
class TeleportTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.token_info = None
        self.scraper = cloudscraper.create_scraper()
        self.attributes = {}
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf)
        self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*")
        self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf)
        self.e_cty.insert(0, "DE")
        self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        pos_frame = ttk.LabelFrame(self, text="Neue Koordinaten")
        pos_frame.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(pos_frame, text="X").grid(row=0, column=0)
        self.e_x_int = ttk.Entry(pos_frame, width=5)
        self.e_x_int.insert(0, "15")
        self.e_x_int.grid(row=0, column=1, padx=4)

        ttk.Label(pos_frame, text="Y").grid(row=0, column=2)
        self.e_y_int = ttk.Entry(pos_frame, width=5)
        self.e_y_int.insert(0, "-1")
        self.e_y_int.grid(row=0, column=3, padx=4)

        ttk.Label(pos_frame, text="Z").grid(row=0, column=4)
        self.e_z_int = ttk.Entry(pos_frame, width=5)
        self.e_z_int.insert(0, "-16")
        self.e_z_int.grid(row=0, column=5, padx=4)

        ttk.Label(self, text="🌍 Raumtyp wählen").pack(pady=(4, 0))
        self.room_type = ttk.Combobox(self, state="readonly", values=[
            "summer_22_plaza",
            "summer_desert",
            "summer_festival_city_beach",
            "summer_festival_vip_club"
        ])
        self.room_type.set("summer_22_plaza")
        self.room_type.pack(pady=(0, pad))

        ttk.Button(self, text="🛰️ Teleportieren", command=self.teleport).pack(pady=pad)

        self.log = ScrolledText(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausfüllen!")

        try:
            self.token_info = login(u, p, c)
            self.token_info["username"] = u
            self.write(f"[OK] Eingeloggt als {u}", "green")
            self.load_attributes()
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def load_attributes(self):
        profile_id = self.token_info['profile_id']
        token = self.token_info['access_token']
        url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{profile_id}/games/j68d/attributes"
        headers = {
            "Authorization": f"Bearer {token}",
            "Accept": "application/json"
        }
        try:
            r = self.scraper.get(url, headers=headers)
            r.raise_for_status()
            data = r.json()
            self.attributes = data.get("additionalData", {})
            self.write("[INFO] Daten erfolgreich geladen.", "cyan")
        except Exception as e:
            self.write(f"[FEHLER] Daten konnten nicht geladen werden: {e}", "red")

    def teleport(self):
        if not self.token_info or not self.attributes:
            return messagebox.showwarning("Fehler", "Bitte zuerst einloggen und Daten laden.")

        try:
            # Sichtbare Eingaben
            x_int = int(self.e_x_int.get())
            y_int = int(self.e_y_int.get())
            z_int = int(self.e_z_int.get())

            # Fest hinterlegte Nachkommastellen
            x_float = float(f"{x_int}.83926010131836")
            y_float = float(f"{y_int}.5668649077415466")
            z_float = float(f"{z_int}.73294997215271")

        except ValueError:
            return messagebox.showerror("Fehler", "Ungültige Zahlen (nur ganze Zahlen erlaubt).")

        try:
            profile_id = self.token_info['profile_id']
            token = self.token_info['access_token']
            url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{profile_id}/games/j68d/attributes"
            headers = {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            }

            payload = {
                "additionalData": dict(self.attributes)
            }

            pos_data = json.loads(payload["additionalData"].get("ChatRoomPositionData", "{}"))
            pos_data["position"] = {"x": x_float, "y": y_float, "z": z_float}
            pos_data["roomType"] = self.room_type.get()
            payload["additionalData"]["ChatRoomPositionData"] = json.dumps(pos_data)

            res = self.scraper.put(url, headers=headers, json=payload)
            if res.status_code == 200:
                self.write(f"[OK] Teleportiert nach {self.room_type.get()} → X:{x_float} Y:{y_float} Z:{z_float}", "green")
            else:
                self.write(f"[FEHLER] Teleport fehlgeschlagen: {res.status_code}", "red")
        except Exception as e:
            self.write(f"[FEHLER] Teleport fehlgeschlagen: {e}", "red")

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_configure(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)


# -------------------- Star Greeting Combo Tab --------------------
class StarGreetingComboTab(ttk.Frame):
    """
    Kombi-Tool mit animiertem Toggle:
      0 = Viele Accounts -> 1 Empfänger (StarGreeting alle 15 min)
      1 = Ein Account    -> Viele Empfänger (StarGreeting alle 15 min)
    """
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()

        # Gemeinsame States
        self.auto_running = False
        self.loop_thread  = None
        self.current_mode = 0  # 0 = MS->ST, 1 = SM->MT

        # --- Mode 0 (multi -> single) ---
        self.ms_accounts = []    # dicts mit access_token, username, password, country
        self.ms_token_refresh_thread = None

        # --- Mode 1 (single -> multi) ---
        self.sm_account   = None
        self.sm_targets   = []
        self.sm_token_refresh_thread = None

        self._build()
        self._start_token_refresh_threads()

    # ---------------- UI ----------------
    def _build(self):
        pad = 6

        # Modus-Umschalter (klein & animiert)
        mf = ttk.LabelFrame(self, text="Modus")
        mf.pack(fill="x", padx=pad, pady=(pad, 0))

        self.mode_label = ttk.Label(mf, text="Viele Accounts → 1 Empfänger")
        self.mode_label.pack(side="right", padx=pad)

        # Wichtig: on_toggle ruft NUR _apply_mode (keine programmatic set-Calls!)
        def _on_toggle(is_on: bool):
            self._apply_mode(1 if is_on else 0)

        self.mode_switch = AnimatedToggleSwitch(mf, value=False, on_toggle=_on_toggle, width=44, height=24)
        self.mode_switch.pack(side="left", padx=pad, pady=(4, 4))

        # Container für beide Modi
        self.container = ttk.Frame(self)
        self.container.pack(fill="both", expand=True, padx=pad, pady=pad)

        # --------- Mode 0 UI  (Viele -> Ein) ---------
        self.frame_ms = ttk.Frame(self.container)

        lf = ttk.LabelFrame(self.frame_ms, text="Login (mehrere Accounts)")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.ms_e_user = ttk.Entry(lf); self.ms_e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.ms_e_pw = ttk.Entry(lf, show="*"); self.ms_e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.ms_e_cty = ttk.Entry(lf); self.ms_e_cty.insert(0, "DE")
        self.ms_e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.ms_login_click).grid(row=3, columnspan=2, pady=(pad, 0))

        # (ENTFERNT) ListeLogin-Buttons

        self.ms_list = tk.Listbox(self.frame_ms, height=5, bg="#000000", fg="white",
                                  selectbackground="#000000", selectforeground="white")
        self.ms_list.pack(fill="x", padx=pad, pady=(0, 2))

        ttk.Button(self.frame_ms, text="❌ Ausgewählten Account entfernen", command=self.ms_remove_selected).pack(padx=pad, pady=(0, pad))

        tf = ttk.LabelFrame(self.frame_ms, text="Empfänger (Name oder profileId)")
        tf.pack(fill="x", padx=pad, pady=pad)
        self.ms_e_target = ttk.Entry(tf)
        self.ms_e_target.pack(fill="x", padx=pad, pady=(pad, 2))
        self.ms_var_target_is_id = tk.BooleanVar(value=False)
        ttk.Checkbutton(tf, text="Eingabe ist bereits profileId",
                        variable=self.ms_var_target_is_id).pack(anchor="w", padx=pad)

        ctl = ttk.Frame(self.frame_ms); ctl.pack(fill="x", padx=pad, pady=(pad, 0))
        ttk.Button(ctl, text="▶️ Start (alle 15 Min.)", command=self.start_loop).pack(side="left")
        ttk.Button(ctl, text="⏹️ Stop", command=self.stop_loop).pack(side="left", padx=(pad, 0))

        # --------- Mode 1 UI  (Ein -> Viele) ---------
        self.frame_sm = ttk.Frame(self.container)

        lfs = ttk.LabelFrame(self.frame_sm, text="Login (ein Account)")
        lfs.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lfs, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.sm_e_user = ttk.Entry(lfs); self.sm_e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lfs, text="Passwort").grid(row=1, column=0, sticky="w")
        self.sm_e_pw = ttk.Entry(lfs, show="*"); self.sm_e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lfs, text="Land").grid(row=2, column=0, sticky="w")
        self.sm_e_cty = ttk.Entry(lfs); self.sm_e_cty.insert(0, "DE")
        self.sm_e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lfs, text="Anmelden", command=self.sm_login_click).grid(row=3, columnspan=2, pady=(pad, 0))

        tgtf = ttk.LabelFrame(self.frame_sm, text="Empfänger verwalten")
        tgtf.pack(fill="both", padx=pad, pady=pad)

        row = ttk.Frame(tgtf); row.pack(fill="x", padx=pad, pady=(pad, 2))
        ttk.Label(row, text="Empfänger (Name oder profileId):").pack(side="left")
        self.sm_e_add = ttk.Entry(row); self.sm_e_add.pack(side="left", fill="x", expand=True, padx=(6, 6))
        ttk.Button(row, text="➕ Hinzufügen", command=self.sm_add_target).pack(side="left")

        self.sm_listbox = tk.Listbox(tgtf, height=6, bg="#000000", fg="white",
                                     selectbackground="#333333", selectforeground="white")
        self.sm_listbox.pack(fill="both", expand=True, padx=pad, pady=(2, 2))

        row2 = ttk.Frame(tgtf); row2.pack(fill="x", padx=pad, pady=(0, pad))
        ttk.Button(row2, text="❌ Entfernen", command=self.sm_remove_selected).pack(side="left")
        ttk.Button(row2, text="🧹 Leeren", command=self.sm_clear_list).pack(side="left", padx=(pad, 0))
        self.sm_var_targets_are_ids = tk.BooleanVar(value=False)
        ttk.Checkbutton(tgtf, text="Alle Einträge sind bereits profileIds",
                        variable=self.sm_var_targets_are_ids).pack(anchor="w", padx=pad, pady=(0, 2))

        ctl2 = ttk.Frame(self.frame_sm); ctl2.pack(fill="x", padx=pad, pady=(pad, 0))
        ttk.Button(ctl2, text="▶️ Start (alle 15 Min.)", command=self.start_loop).pack(side="left")
        ttk.Button(ctl2, text="⏹️ Stop", command=self.stop_loop).pack(side="left", padx=(pad, 0))

        # --------- Log ----------
        self.log = ScrolledText(self, height=14, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

        # Initiale Ansicht NUR programmatisch setzen (Switch ohne Callback anpassen)
        self._switch_mode(0)

    # --------- Neue Trennung: Anwenden vs. Setzen ----------
    def _apply_mode(self, m: int):
        """Nur Frames/Label aktualisieren, KEIN set() auf dem Switch!"""
        self.current_mode = m
        for child in (self.frame_ms, self.frame_sm):
            child.pack_forget()
        if m == 0:
            self.frame_ms.pack(fill="both", expand=True)
            self.mode_label.config(text="Viele Accounts → 1 Empfänger")
        else:
            self.frame_sm.pack(fill="both", expand=True)
            self.mode_label.config(text="Ein Account → Viele Empfänger")

    def _switch_mode(self, m: int):
        """Programmatische Umschaltung: Switch-Status setzen OHNE on_toggle, danach UI anwenden."""
        self.mode_switch.set(m == 1, trigger=False)  # kein Callback feuern
        self._apply_mode(m)

    # ---------------- Helpers / (… Rest bleibt wie gehabt) ----------------
    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        if int(self.log.index("end-1c").split(".")[0]) > 500:
            self.log.delete("1.0", "120.0")
        self.log.see(tk.END)

    def _looks_like_uuid(self, s: str) -> bool:
        s = s.strip().lower()
        return len(s) == 32 and all(c in "0123456789abcdef" for c in s)

    def _start_token_refresh_threads(self):
        def ms_refresh():
            while True:
                time.sleep(3600)
                for i, acc in enumerate(list(self.ms_accounts)):
                    try:
                        new_token = login(acc["username"], acc["password"], acc["country"])
                        new_token["username"] = acc["username"]
                        new_token["password"] = acc["password"]
                        new_token["country"]  = acc["country"]
                        self.ms_accounts[i] = new_token
                        self.write(f"[REFRESH] Token erneuert für {acc['username']}", "cyan")
                    except Exception as e:
                        self.write(f"[FEHLER] Token-Refresh (MS) {acc.get('username','?')}: {e}", "red")
        threading.Thread(target=ms_refresh, daemon=True).start()

        def sm_refresh():
            while True:
                time.sleep(3600)
                if not self.sm_account:
                    continue
                try:
                    acc = self.sm_account
                    new_token = login(acc["username"], acc["password"], acc["country"])
                    new_token["username"] = acc["username"]
                    new_token["password"] = acc["password"]
                    new_token["country"]  = acc["country"]
                    self.sm_account = new_token
                    self.write(f"[REFRESH] Token erneuert für {acc['username']}", "cyan")
                except Exception as e:
                    self.write(f"[FEHLER] Token-Refresh (SM): {e}", "red")
        threading.Thread(target=sm_refresh, daemon=True).start()

    # ---------------- Logins ----------------
    # Mode 0
    def ms_login_click(self):
        u = self.ms_e_user.get().strip()
        p = self.ms_e_pw.get().strip()
        c = self.ms_e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausfüllen!")
        try:
            acc = login(u, p, c)
            acc["username"] = u; acc["password"] = p; acc["country"] = c
            self.ms_accounts.append(acc)
            self.ms_list.insert(tk.END, u)
            self.write(f"[OK] Eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")

    def ms_login_from_file(self, filename):
        try:
            base_dir = os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)
            full_path = os.path.join(base_dir, filename)
            self.write(f"[DEBUG] Lese Datei: {full_path}", "yellow")
            with open(full_path, "r", encoding="utf-8") as f:
                lines = f.readlines()
            added = 0
            for line in lines:
                parts = line.strip().split(":")
                if len(parts) < 2:
                    continue
                u = parts[0].strip()
                p = parts[1].strip()
                c = parts[2].strip().upper() if len(parts) > 2 else "DE"
                try:
                    acc = login(u, p, c)
                    acc["username"] = u; acc["password"] = p; acc["country"] = c
                    self.ms_accounts.append(acc)
                    self.ms_list.insert(tk.END, u)
                    added += 1
                except Exception as e:
                    self.write(f"[FEHLER] {u}: {e}", "red")
            self.write(f"[INFO] {added} Accounts geladen.", "cyan")
        except Exception as e:
            self.write(f"[FEHLER] Datei: {e}", "red")

    def ms_remove_selected(self):
        sel = self.ms_list.curselection()
        if not sel:
            return
        idx = sel[0]
        acc = self.ms_accounts[idx]
        self.ms_list.delete(idx)
        del self.ms_accounts[idx]
        self.write(f"[INFO] Account entfernt: {acc.get('username','?')}", "yellow")

    # Mode 1
    def sm_login_click(self):
        u = self.sm_e_user.get().strip()
        p = self.sm_e_pw.get().strip()
        c = self.sm_e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausfüllen!")
        try:
            acc = login(u, p, c)
            acc["username"] = u; acc["password"] = p; acc["country"] = c
            self.sm_account = acc
            self.write(f"[OK] Eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")

    # Empfänger-Management (Mode 1)
    def sm_add_target(self):
        val = self.sm_e_add.get().strip()
        if not val:
            return
        self.sm_listbox.insert(tk.END, val)
        self.sm_e_add.delete(0, tk.END)

    def sm_remove_selected(self):
        sel = self.sm_listbox.curselection()
        if not sel:
            return
        self.sm_listbox.delete(sel[0])

    def sm_clear_list(self):
        self.sm_listbox.delete(0, tk.END)

    # ---------------- API ----------------
    def find_profile_id(self, username, region):
        """
        Sucht die profileId über edgerelationships.findProfiles.
        Verwendet self.token_info['access_token'] (wie von dir gewünscht).
        """
        try:
            if not hasattr(self, "token_info") or not self.token_info or "access_token" not in self.token_info:
                self.write("[FEHLER] Kein Token für Profilsuche vorhanden (self.token_info fehlt).", "red")
                return None

            name = (username or "").strip()
            if not name:
                self.write("[FEHLER] Leerer Name für Profilsuche.", "red")
                return None

            url = "https://eu.mspapis.com/edgerelationships/graphql/graphql"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Content-Type": "application/json"
            }
            query = """
            query GetProfileSearch($region: String!, $startsWith: String!, $pageSize: Int, $currentPage: Int, $preferredGameId: String!) {
                findProfiles(region: $region, nameBeginsWith: $startsWith, pageSize: $pageSize, page: $currentPage) {
                    totalCount
                    nodes {
                        id
                        avatar(preferredGameId: $preferredGameId) {
                            gameId
                            face
                            full
                        }
                    }
                }
            }
            """
            variables = {
                "region": region,
                "startsWith": name,
                "pageSize": 50,
                "currentPage": 1,
                "preferredGameId": "j68d"
            }
            payload = {"query": query, "variables": variables}

            r = self.scraper.post(url, headers=headers, json=payload, timeout=15)
            r.raise_for_status()
            data = r.json()
            nodes = data.get("data", {}).get("findProfiles", {}).get("nodes", [])
            if not nodes:
                self.write(f"[FEHLER] Kein Profil mit dem Namen '{name}' gefunden.", "red")
                return None
            return nodes[0]["id"]
        except Exception as e:
            self.write(f"[FEHLER] Profil-ID konnte nicht ermittelt werden: {e}", "red")
            return None

    def send_star_greeting(self, access_token, receiver_profile_id, label):
        try:
            url = "https://eu.mspapis.com/federationgateway/graphql"
            headers = {"Authorization": f"Bearer {access_token}", "Content-Type": "application/json"}
            payload = {
                "id": "SendGreetings-159BDD7706D824BB8F14874A7FAE3368",
                "variables": {
                    "greetingType": "StarGreeting",
                    "receiverProfileId": receiver_profile_id,
                    "ignoreDailyCap": False
                }
            }
            r = self.scraper.post(url, headers=headers, json=payload, timeout=12)
            r.raise_for_status()
            data = r.json()
            success = (
                data.get("data", {}).get("greetings", {}).get("sendGreeting", {}).get("success", False)
            ) or (
                data.get("data", {}).get("sendGreeting", {}).get("success", False)
            )
            if success:
                self.write(f"[OK] StarGreeting → {label}", "green")
            else:
                self.write(f"[FEHLER] StarGreeting → {label} fehlgeschlagen.", "red")
        except Exception as e:
            self.write(f"[FEHLER] StarGreeting → {label}: {e}", "red")

    # ---------------- Loop Control ----------------
    def start_loop(self):
        if self.auto_running:
            return self.write("[INFO] Läuft bereits.", "yellow")

        m = self.current_mode
        if m == 0:
            # MS → ST
            if not self.ms_accounts:
                return messagebox.showwarning("Fehler", "Bitte mindestens einen Account einloggen.")
            if not self.ms_e_target.get().strip():
                return messagebox.showwarning("Fehler", "Empfänger angeben!")
        else:
            # SM → MT
            if not self.sm_account:
                return messagebox.showwarning("Fehler", "Bitte zuerst einloggen!")
            if self.sm_listbox.size() == 0:
                return messagebox.showwarning("Fehler", "Keine Empfänger in der Liste!")

        self.auto_running = True
        self.loop_thread = threading.Thread(target=self._loop, daemon=True)
        self.loop_thread.start()
        self.write("[INFO] Auto-Run gestartet (Intervall 15 Min.)", "cyan")

    def stop_loop(self):
        self.auto_running = False
        self.write("[INFO] Gestoppt.", "yellow")

    def _loop(self):
        INTERVAL = 15 * 60  # 15 Minuten
        while self.auto_running:
            mode_now = self.current_mode
            try:
                if mode_now == 0:
                    self._run_mode_ms()
                else:
                    self._run_mode_sm()
            except Exception as e:
                self.write(f"[FEHLER] Run: {e}", "red")

            # Warten bis nächste Runde
            if not self.auto_running:
                break
            for remain in range(INTERVAL, 0, -1):
                if not self.auto_running:
                    break
                if remain % 30 == 0 or remain <= 10:
                    self.write(f"[WARTEN] Nächste Runde in {remain}s ...", "cyan")
                time.sleep(1)

        self.write("[INFO] Auto-Run beendet.", "yellow")

    # --- Runde: Mode 0 (Viele -> Ein) ---
    def _run_mode_ms(self):
        target_raw = self.ms_e_target.get().strip()
        treat_as_id = self.ms_var_target_is_id.get()
        if not target_raw:
            self.write("[FEHLER] Kein Empfänger gesetzt.", "red")
            return

        # Ziel-ID auflösen (einmalig)
        first_acc = self.ms_accounts[0]
        region = first_acc.get("country", "DE").upper()
        # WICHTIG: Tokenquelle setzen, damit find_profile_id darauf zugreift
        self.token_info = first_acc

        if treat_as_id or self._looks_like_uuid(target_raw) or "|" in target_raw:
            receiver_id = target_raw
            label = target_raw
        else:
            receiver_id = self.find_profile_id(target_raw, region)
            if not receiver_id:
                return
            label = f"{target_raw} ({receiver_id})"

        # Jeder Account sendet 1x
        for acc in list(self.ms_accounts):
            if not self.auto_running:
                break
            self.send_star_greeting(acc["access_token"], receiver_id, f"{label} ← {acc.get('username','?')}")
            time.sleep(1)

    # --- Runde: Mode 1 (Ein -> Viele) ---
    def _run_mode_sm(self):
        acc = self.sm_account
        region = acc.get("country", "DE").upper()
        # WICHTIG: Tokenquelle setzen
        self.token_info = acc

        entries = [self.sm_listbox.get(i) for i in range(self.sm_listbox.size())]
        treat_as_ids = self.sm_var_targets_are_ids.get()
        if not entries:
            self.write("[INFO] Keine Empfänger vorhanden.", "yellow")
            return

        for item in list(entries):
            if not self.auto_running:
                break

            if treat_as_ids or self._looks_like_uuid(item) or "|" in item:
                receiver_id = item
                label = item
            else:
                receiver_id = self.find_profile_id(item.strip(), region)
                if not receiver_id:
                    continue
                label = f"{item} ({receiver_id})"

            self.send_star_greeting(acc["access_token"], receiver_id, label)
            time.sleep(1)


class SpecialMassSenderTab(ttk.Frame):
    """
    Zwei Logins (jeweils doppelt), Ziel (Name oder profileId) eingeben,
    Greeting-Typ wählen und 'N' parallele Anfragen *pro Account* abfeuern.
    Buttons: Threads vorbereiten -> gemeinsamer Start -> Stop.
    """
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.accounts = []            # Liste von token_info Dicts (je Login 2x)
        self.threads = []
        self.start_event = threading.Event()
        self.running = False
        self.token_info = None        # wird für find_profile_id verwendet (siehe Wunsch)
        self._build()

    # ---------- UI ----------
    def _build(self):
        pad = 6

        lf = ttk.LabelFrame(self, text="Logins einzeln (jeder wird doppelt eingeloggt)")
        lf.pack(fill="x", padx=pad, pady=pad)

        for i in range(2):
            ttk.Label(lf, text=f"Benutzer {i+1}").grid(row=i*4, column=0, sticky="w")
            setattr(self, f"e_user{i}", ttk.Entry(lf))
            getattr(self, f"e_user{i}").grid(row=i*4, column=1, padx=pad)

            ttk.Label(lf, text="Passwort").grid(row=i*4+1, column=0, sticky="w")
            setattr(self, f"e_pw{i}", ttk.Entry(lf, show="*"))
            getattr(self, f"e_pw{i}").grid(row=i*4+1, column=1, padx=pad)

            ttk.Label(lf, text="Land").grid(row=i*4+2, column=0, sticky="w")
            e_cty = ttk.Entry(lf); e_cty.insert(0, "DE")
            setattr(self, f"e_cty{i}", e_cty)
            e_cty.grid(row=i*4+2, column=1, padx=pad)

            ttk.Button(lf, text=f"Login Benutzer {i+1}",
                       command=lambda idx=i: self.login_click(idx)).grid(row=i*4+3, columnspan=2, pady=pad)

        tf = ttk.LabelFrame(self, text="🎯 Ziel & Einstellungen")
        tf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(tf, text="Ziel (Name oder profileId):").grid(row=0, column=0, sticky="w")
        self.e_target = ttk.Entry(tf); self.e_target.grid(row=0, column=1, sticky="ew", padx=pad)
        tf.columnconfigure(1, weight=1)

        self.var_is_id = tk.BooleanVar(value=False)
        ttk.Checkbutton(tf, text="Eingabe ist bereits profileId",
                        variable=self.var_is_id).grid(row=1, column=1, sticky="w", padx=pad, pady=(0, 4))

        ttk.Label(tf, text="Greeting-Typ:").grid(row=2, column=0, sticky="w")
        self.greeting_var = tk.StringVar(value="StarGreeting")
        ttk.Combobox(tf, textvariable=self.greeting_var,
                     values=["StarGreeting", "Autograph"],
                     state="readonly", width=18).grid(row=2, column=1, sticky="w", padx=pad, pady=(0, 4))

        ttk.Label(tf, text="Parallele Anfragen pro Account:").grid(row=3, column=0, sticky="w")
        self.per_acc_threads = tk.IntVar(value=20)
        ttk.Spinbox(tf, from_=1, to=200, textvariable=self.per_acc_threads, width=6)\
           .grid(row=3, column=1, sticky="w", padx=pad)

        ttk.Button(self, text="🧠 Threads vorbereiten", command=self.prepare_threads).pack(pady=pad)
        ttk.Button(self, text="🎯 Jetzt starten", command=self.start_event.set).pack(pady=(0, pad))
        ttk.Button(self, text="⏹️ Stop", command=self.stop).pack(pady=(0, pad))

        self.log = ScrolledText(self, height=12, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    # ---------- Login ----------
    def login_click(self, idx: int):
        u = getattr(self, f"e_user{idx}").get().strip()
        p = getattr(self, f"e_pw{idx}").get().strip()
        c = getattr(self, f"e_cty{idx}").get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausfüllen!")

        try:
            for _ in range(2):  # doppelt einloggen (wie gewünscht)
                token_info = login(u, p, c)
                token_info["username"] = u
                token_info["country"]  = c
                self.accounts.append(token_info)
            self.write(f"[OK] Benutzer {idx+1} doppelt eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login Benutzer {idx+1}: {e}", "red")
            messagebox.showerror("Login", str(e))

    # ---------- Threads vorbereiten ----------
    def prepare_threads(self):
        if not self.accounts:
            return messagebox.showwarning("Fehler", "Bitte mindestens einen Benutzer einloggen.")

        target_raw = (self.e_target.get() or "").strip()
        if not target_raw:
            return messagebox.showwarning("Fehler", "Bitte Ziel eingeben.")

        # Für die gewünschte find_profile_id verwenden wir self.token_info (= erster Account)
        self.token_info = self.accounts[0]
        region = self.token_info.get("country", "DE").upper()

        if self.var_is_id.get() or self._looks_like_uuid(target_raw) or "|" in target_raw:
            receiver_id = target_raw
            label = target_raw
        else:
            receiver_id = self.find_profile_id(target_raw, region)  # *** exakt nach deiner Vorlage ***
            if not receiver_id:
                return
            label = f"{target_raw} ({receiver_id})"

        self.threads.clear()
        self.start_event.clear()
        self.running = True

        per_acc = max(1, int(self.per_acc_threads.get()))
        greeting_type = self.greeting_var.get()

        for acc in self.accounts:
            token = acc["access_token"]
            for _ in range(per_acc):
                t = threading.Thread(
                    target=self._worker_send_once,
                    args=(token, receiver_id, greeting_type, f"{label} ← {acc.get('username','?')}"),
                    daemon=True
                )
                self.threads.append(t)

        for t in self.threads:
            t.start()

        self.write(f"[INFO] {len(self.accounts)} Accounts × {per_acc} Threads vorbereitet "
                   f"(gesamt {len(self.threads)}). Klicke jetzt auf '🎯 Jetzt starten'.", "cyan")

    def _worker_send_once(self, token, receiver_id, greeting_type, label):
        self.start_event.wait()   # Synchronstart
        if not self.running:
            return
        self._send_greeting_once(token, receiver_id, greeting_type, label)

    def stop(self):
        self.running = False
        self.start_event.set()
        self.write("[INFO] gestoppt.", "yellow")

    # ---------- Request ----------
    def _send_greeting_once(self, access_token, receiver_profile_id, greeting_type, label):
        try:
            url = "https://eu.mspapis.com/federationgateway/graphql"
            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json",
                "Referer": "https://moviestarplanet2.com/",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36"
            }
            payload = {
                "id": "SendGreetings-159BDD7706D824BB8F14874A7FAE3368",
                "variables": {
                    "greetingType": greeting_type,   # "StarGreeting" oder "Autograph"
                    "receiverProfileId": receiver_profile_id,
                    "ignoreDailyCap": False
                }
            }
            res = self.scraper.post(url, headers=headers, json=payload, timeout=8)
            res.raise_for_status()
            data = res.json()
            success = (
                data.get("data", {}).get("greetings", {}).get("sendGreeting", {}).get("success", False)
            ) or (
                data.get("data", {}).get("sendGreeting", {}).get("success", False)
            )
            if success:
                self.after(0, self.write, f"[OK] {greeting_type} → {label}", "green")
            else:
                self.after(0, self.write, f"[FEHLER] {greeting_type} → {label} fehlgeschlagen.", "red")
        except Exception as e:
            self.after(0, self.write, f"[FEHLER] {greeting_type} → {label}: {e}", "red")

    # ---------- Utils ----------
    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

    def _looks_like_uuid(self, s: str) -> bool:
        s = (s or "").strip().lower()
        return len(s) == 32 and all(c in "0123456789abcdef" for c in s)

    # *** exakt DEINE gewünschte find_profile_id – unverändert übernommen ***
    def find_profile_id(self, username, region):
        try:
            url = "https://eu.mspapis.com/edgerelationships/graphql/graphql"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Content-Type": "application/json"
            }
            query = """
            query GetProfileSearch($region: String!, $startsWith: String!, $pageSize: Int, $currentPage: Int, $preferredGameId: String!) {
                findProfiles(region: $region, nameBeginsWith: $startsWith, pageSize: $pageSize, page: $currentPage) {
                    totalCount
                    nodes {
                        id
                        avatar(preferredGameId: $preferredGameId) {
                            gameId
                            face
                            full
                        }
                    }
                }
            }
            """
            variables = {
                "region": region,
                "startsWith": username,
                "pageSize": 50,
                "currentPage": 1,
                "preferredGameId": "j68d"
            }
            payload = {"query": query, "variables": variables}
            r = self.scraper.post(url, headers=headers, json=payload)
            r.raise_for_status()
            data = r.json()
            nodes = data.get("data", {}).get("findProfiles", {}).get("nodes", [])
            if not nodes:
                self.write(f"[FEHLER] Kein Profil mit dem Namen '{username}' gefunden.", "red")
                return None
            return nodes[0]["id"]
        except Exception as e:
            self.write(f"[FEHLER] Profil-ID konnte nicht ermittelt werden: {e}", "red")
            return None
        
# -------------------- Password Change Tab --------------------
# -------------------- Password Change Tab (Identity-Bearer direkt) --------------------
class PasswordChangeTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.token_info = None
        self.identity_access_token = None
        self.identity_claims = {}
        self.country = "DE"
        self.game_id = "j68d"
        self.display_name = ""
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login"); lf.pack(fill="x", padx=pad, pady=pad)
        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0, "DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        cf = ttk.LabelFrame(self, text="Passwort ändern"); cf.pack(fill="x", padx=pad, pady=pad)
        ttk.Label(cf, text="Neues Passwort").grid(row=0, column=0, sticky="w")
        self.e_new_pw = ttk.Entry(cf, show="*"); self.e_new_pw.grid(row=0, column=1, padx=pad)

        ttk.Button(self, text="Ändern", command=self.change_password_click).pack(pady=(0, pad))

        self.claim_text = tk.StringVar()
        ttk.Label(self, textvariable=self.claim_text, justify="left").pack(pady=(0, pad))

        self.log = ScrolledText(self, height=12, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

    def _looks_like_guid(self, s: str) -> bool:
        s = (s or "").strip()
        return len(s) == 32 and all(c in "0123456789abcdef" for c in s.lower())

    def _jwt_payload(self, jwt_token: str) -> dict:
        try:
            parts = jwt_token.split(".")
            if len(parts) < 2:
                return {}
            import base64, json
            pad_len = (-len(parts[1]) % 4)
            payload = base64.urlsafe_b64decode(parts[1] + ("=" * pad_len))
            return json.loads(payload.decode("utf-8", errors="ignore"))
        except Exception:
            return {}

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausfüllen!")
        self.country = c
        try:
            acc = login(u, p, c)
            acc["username"] = u
            acc["password"] = p
            acc["country"] = c
            self.token_info = acc
            self.display_name = acc.get("username", u)
            self.write(f"[OK] Eingeloggt als {u}", "green")

            at = self.token_info.get("access_token", "")
            claims = self._jwt_payload(at)
            if at:
                self.identity_access_token = acc.get("access_token", "")
                self.identity_claims = self._jwt_payload(self.identity_access_token)
                self.write("[OK] Identity-Access-Token übernommen.", "green")

                # Zeige Claims
                pretty = "\n".join([f"{k}: {v}" for k, v in self.identity_claims.items()])
                self.claim_text.set(f"🔐 JWT Claims:\n{pretty}")
            else:
                self.write("[WARN] Identity-Token fehlte – GraphQL wird fehlschlagen.", "yellow")

        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")
            messagebox.showerror("Login", str(e))


    def change_password_click(self):
        if not self.token_info:
            return messagebox.showwarning("Nicht eingeloggt", "Bitte zuerst einloggen.")
        if not self.identity_access_token:
            self.write("[FEHLER] Identity-Token fehlt – Passwort ändern nicht möglich.", "red")
            return

        new_pw = self.e_new_pw.get().strip()
        if not new_pw:
            return messagebox.showwarning("Fehler", "Neues Passwort eingeben.")

        login_id = self.identity_claims.get("loginId") or self.identity_claims.get("sub") or ""
        if not login_id:
            self.write("[FEHLER] Konnte loginId nicht aus Identity-Token lesen.", "red")
            return

        profile_id = self.token_info.get("profile_id", "")
        if not profile_id:
            self.write("[FEHLER] profile_id fehlt aus Game-Login.", "red")
            return

        name = self.display_name or self.token_info.get("username", "")

        try:
            ok = self._change_password_edgelogins(
                bearer=self.identity_access_token,
                login_id=login_id,
                profile_id=profile_id,
                game_id=self.game_id,
                name=name,
                current_password=self.token_info.get("password", ""),
                new_password=new_pw,
                is_guest=False
            )
            if ok:
                self.write("[OK] Passwort erfolgreich geändert.", "green")
            else:
                self.write("[FEHLER] Passwort ändern fehlgeschlagen (siehe Log).", "red")
        except Exception as e:
            self.write(f"[FEHLER] Passwort ändern: {e}", "red")

    def _change_password_edgelogins(self, bearer: str, login_id: str, profile_id: str,
                                    game_id: str, name: str,
                                    current_password: str, new_password: str,
                                    is_guest: bool = False) -> bool:
        """
        Führt die GraphQL-Mutation auf edgelogins mit DEM Identity-Bearer aus.
        """
        url = "https://edgelogins.eu.moviestarplanet.app/graphql"
        headers = {
            "Authorization": f"Bearer {bearer}",
            "Content-Type": "application/json",
            "Referer": "https://moviestarplanet2.com/",
            "User-Agent": "Mozilla/5.0",
            "sec-ch-ua": "\"Opera GX\";v=\"120\", \"Not-A.Brand\";v=\"8\", \"Chromium\";v=\"135\"",
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "\"Windows\"",
        }

        query = (
            "mutation UpdateLogin($loginId: String!, $profileId: String!, $gameId: String!, $name: String, "
            "$currentPassword: String!, $newPassword: String!, $isGuest: Boolean){"
            "updateLoginProfile(input: { loginId: $loginId, profileId: $profileId, gameId: $gameId, name: $name, "
            "passwords: { currentPassword: $currentPassword, newPassword: $newPassword}, isGuest: $isGuest}) "
            "{success,loginProfile {loginId,loginName,profileId,profileName,isGuest},error}}"
        )

        variables = {
            "loginId": login_id,
            "profileId": profile_id,
            "gameId": game_id,
            "name": name,
            "currentPassword": current_password,
            "newPassword": new_password,
            "isGuest": bool(is_guest),
        }

        # WICHTIG: variables NICHT als String übergeben!
        payload = {"query": query, "variables": variables}

        try:
            self.write(f"[DEBUG] GraphQL Variables:\n{json.dumps(variables, indent=2)}", "yellow")
            r = self.scraper.post(url, headers=headers, json=payload, timeout=20)
            r.raise_for_status()
            js = r.json()

            if "errors" in js and js["errors"]:
                self.write(f"[FEHLER] GraphQL-Errors: {js['errors']}", "red")
                return False

            data = js.get("data", {}).get("updateLoginProfile", {})
            if not data:
                self.write(f"[FEHLER] Unerwartete Antwort: {js}", "red")
                return False

            if data.get("success") is True:
                lp = data.get("loginProfile") or {}
                self.write(f"[OK] Änderung bestätigt: {lp.get('loginName')} / {lp.get('profileName')}", "green")
                return True

            self.write(f"[FEHLER] Änderung fehlgeschlagen: {data.get('error')}", "red")
            return False

        except Exception as e:
            self.write(f"[FEHLER] HTTP: {e}", "red")
            return False


# -------------------- Main Window --------------------
class MSP2Toolkit(tk.Tk):
    def __init__(self):
        super().__init__()
        self.iconbitmap(resource_path("rabbit.ico"))
        setup_style(self)
        self.title("NiveDev v2.0")
        self.geometry("740x770")

        # Logo
        img = Image.open(resource_path("rabbit.jpg"))
        img = img.resize((60, 60), Image.LANCZOS)
        self.logo_img = ImageTk.PhotoImage(img)
        ttk.Label(self, image=self.logo_img, anchor="center").pack(pady=(10, 0))

        # Hauptcontainer
        self.wrapper = ttk.Frame(self)
        self.wrapper.pack(fill="both", expand=True)

        # Notebook – versteckt Tabs mit "tabposition"
        self.nb = ttk.Notebook(self.wrapper)
        self.nb.enable_traversal()
        self.nb.pack_forget()

        # Tools initialisieren
        self.tabs = {}
        self.tool_configs = [
            ("LoveIt", LoveItTab),
            ("Token", TokenRunnerTab),
            ("Gender", GenderSwitchTab),
            ("Autos", AutographTab),
            ("Dupli", GiftOpenerTab),
            ("Daily", DailyLogin),
            ("Teleport", TeleportTab),
            ("DFW", StarGreetingComboTab),
            ("Passwort", PasswordChangeTab),
        ]

        for name, TabClass in self.tool_configs:
            frame = ttk.Frame(self.nb)
            tab = TabClass(frame)

            # BACK Button hinzufügen
            back_btn = ttk.Button(frame, text="⬅️ Back", command=self.back_to_menu)
            back_btn.pack(anchor="w", padx=10, pady=10)
            tab.pack(fill="both", expand=True)
            self.nb.add(frame, text=name)
            self.tabs[name] = frame

        # Menü anzeigen
        self.menu_frame = ttk.Frame(self.wrapper)
        self.menu_frame.pack(pady=10)
        self.create_tool_buttons()

    def create_tool_buttons(self):
        for i, (name, _) in enumerate(self.tool_configs):
            btn = tk.Button(
                self.menu_frame,
                text=name,
                command=lambda i=i: self.select_tab(i),
                font=("Comic Sans MS", 10, "bold"),
                bg="#941515",
                fg="white",
                relief="flat",
                padx=14,
                pady=10,
                bd=0,
                cursor="hand2",
                width=10,
                height=2,
            )
            btn.pack(side="left", padx=8, pady=8)

    def select_tab(self, index: int):
        self.menu_frame.pack_forget()
        self.nb.pack(fill="both", expand=True, padx=6, pady=6)
        self.nb.select(index)

    def back_to_menu(self):
        self.nb.pack_forget()
        self.menu_frame.pack(pady=10)

if __name__ == "__main__":
    MSP2Toolkit().mainloop()
