import json, time, random, queue, threading, base64
from typing import List, Dict, Optional
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
from tkinter.scrolledtext import ScrolledText
import requests, cloudscraper
import binascii
import struct
import zlib
import os
import sys
import random
import re
import uuid
import urllib.parse
import threading
from concurrent.futures import ThreadPoolExecutor
from PIL import Image, ImageTk
from auth import login
from ugc  import load_ugcs, loveit

def resource_path(relative_path):
    base_path = getattr(sys, '_MEIPASS', os.path.abspath(os.path.dirname(__file__)))
    return os.path.join(base_path, relative_path)

# --- kleiner, animierter ToggleSwitch (Canvas) ---
class AnimatedToggleSwitch(ttk.Frame):
    def __init__(self, master, value=False, on_toggle=None, width=44, height=24):
        super().__init__(master)
        self.on_toggle = on_toggle
        self.w = width
        self.h = height
        self.pad = 2
        self._is_on = bool(value)
        self._animating = False

        self.canvas = tk.Canvas(self, width=self.w, height=self.h, highlightthickness=0, bg=self._bg())
        self.canvas.pack()
        self.canvas.bind("<Button-1>", self._click)

        # IDs
        self._track_id = None
        self._knob_id  = None
        self._draw_static()
        self._place_knob(instant=True)

    def set(self, value: bool, trigger: bool = True):
        """Extern Status setzen (ohne Animation)."""
        self._is_on = bool(value)
        self._place_knob(instant=True)
        if trigger and self.on_toggle:
            self.on_toggle(self._is_on)

    def _bg(self):
        """Hintergrundfarbe robust ermitteln (ttk-sicher)."""
        try:
            return self.master.cget("background")
        except Exception:
            pass
        try:
            style = ttk.Style()
            try:
                style_name = self.master.cget("style") or ""
            except Exception:
                style_name = ""
            candidates = [style_name, self.master.winfo_class(), "TFrame", "TLabelframe"]
            for name in candidates:
                if not name:
                    continue
                col = style.lookup(name, "background")
                if col:
                    return col
        except Exception:
            pass
        return "#FFFFFF"

    def _draw_static(self):
        self.canvas.delete("all")
        radius = self.h / 2
        fill = "#22c55e" if self._is_on else "#4b5563"
        self._track_id = self._round_rect(self.pad, self.pad, self.w - self.pad, self.h - self.pad,
                                          radius - 2, fill=fill, outline="")
        size = self.h - 2 * self.pad
        self._knob_id = self.canvas.create_oval(self.pad, self.pad, self.pad + size, self.pad + size,
                                                fill="#FFFFFF", outline="")

    def _round_rect(self, x1, y1, x2, y2, r, **kwargs):
        points = [
            x1 + r, y1, x2 - r, y1,
            x2, y1, x2, y1 + r,
            x2, y2 - r, x2, y2,
            x2 - r, y2, x1 + r, y2,
            x1, y2, x1, y2 - r,
            x1, y1 + r, x1, y1,
        ]
        return self.canvas.create_polygon(points, smooth=True, **kwargs)

    def _click(self, _evt=None):
        if self._animating:
            return
        target = not self._is_on
        self._animate_to(target)

    def _place_knob(self, instant=False):
        size = self.h - 2 * self.pad
        left_x  = self.pad
        right_x = self.w - self.pad - size
        x = right_x if self._is_on else left_x
        self.canvas.coords(self._knob_id, x, self.pad, x + size, self.pad + size)
        self.canvas.itemconfig(self._track_id, fill="#22c55e" if self._is_on else "#4b5563")

    def _animate_to(self, target_on: bool):
        """Animiert zum Zielzustand und ruft den Callback NACH der Animation auf."""
        if target_on == self._is_on:
            # Nichts zu tun
            self._place_knob(instant=True)
            return

        self._animating = True
        steps = 8
        dur_ms = 90

        size = self.h - 2 * self.pad
        left_x  = self.pad
        right_x = self.w - self.pad - size

        # Start/Ziel
        coords = self.canvas.coords(self._knob_id)
        x_now = coords[0] if coords else (right_x if self._is_on else left_x)
        x_end = right_x if target_on else left_x
        delta = (x_end - x_now) / steps if steps else 0

        # Farbverlauf
        def hex_to_rgb(h):
            h = h.lstrip("#")
            return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))
        def rgb_to_hex(t):
            return f"#{t[0]:02x}{t[1]:02x}{t[2]:02x}"
        def lerp(a, b, t): return int(a + (b - a) * t)

        start_col = hex_to_rgb(self.canvas.itemcget(self._track_id, "fill") or ("#22c55e" if self._is_on else "#4b5563"))
        end_col   = hex_to_rgb("#22c55e" if target_on else "#4b5563")

        def step(i=0, x=x_now):
            t = i / steps if steps else 1
            r = lerp(start_col[0], end_col[0], t)
            g = lerp(start_col[1], end_col[1], t)
            b = lerp(start_col[2], end_col[2], t)
            self.canvas.itemconfig(self._track_id, fill=rgb_to_hex((r, g, b)))
            self.canvas.coords(self._knob_id, x, self.pad, x + size, self.pad + size)
            if i < steps:
                self.after(max(1, dur_ms // steps), step, i + 1, x + delta)
            else:
                # Ziel fixieren & Status √ºbernehmen
                self._is_on = target_on
                self._place_knob(instant=True)
                self._animating = False
                if self.on_toggle:
                    # Callback erst am Ende ausf√ºhren
                    try:
                        self.on_toggle(self._is_on)
                    except Exception:
                        pass

        step()


# -------------------- Style (dark blue) --------------------
def setup_style(root: tk.Tk):
    style = ttk.Style(root)
    style.theme_use("clam")

    # Schwarz-Rot-Farbschema
    bg  = "#000000"   # tiefes Schwarz
    fg  = "#ffffff"   # Wei√ü f√ºr Text
    acc = "#941515"   # kr√§ftiges Rot
    hl  = "#000000"   # dunkles Grau

    root.configure(bg=bg)
    style.configure(".", background=bg, foreground=fg, font=("Comic Sans MS", 10))
    style.configure("TFrame", background=bg)
    style.configure("TLabel", background=bg, foreground=fg)
    style.configure("TLabelFrame", background=bg, foreground=acc, font=("Comic Sans MS", 10, "bold"))
    style.configure("TButton", padding=6, relief="flat", background=acc, foreground="white")
    style.map("TButton", background=[("active", "#941515")])
    style.configure("TEntry", fieldbackground="#000000", foreground=fg, insertcolor=fg)
    style.configure("TNotebook", background=bg)
    style.configure("TNotebook.Tab", background=hl, foreground=fg, padding=(12, 6))
    style.map("TNotebook.Tab", background=[("selected", acc)], foreground=[("selected", "white")])


# -------------------- Shared Tokens -----------------------
shared_tokens: List[Dict] = []


# -------------------- LoveIt Tab --------------------------
class LoveItTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.ugcs: List[Dict] = []
        self.log_q, self.prog_q = queue.Queue(), queue.Queue()
        self._build(); self._poll()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login"); lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w"); 
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w"); 
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w"); 
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0,"DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3,columnspan=2,pady=pad)

        self.tok_var = tk.StringVar(value="Tokens: 0")
        ttk.Label(lf, textvariable=self.tok_var).grid(row=4,columnspan=2)

        tf = ttk.Frame(self); tf.pack(fill="x", padx=pad)
        ttk.Button(tf, text="Load tokens.json", command=self.load_tokens).pack(side="left", padx=pad)

        ugcf = ttk.LabelFrame(self, text="UGCs"); ugcf.pack(fill="both",expand=True,padx=pad,pady=pad)
        self.lb = tk.Listbox(ugcf, selectmode=tk.MULTIPLE, bg="#000000", fg="#ffffff")
        self.lb.pack(side="left",fill="both",expand=True)
        sb  = ttk.Scrollbar(ugcf, command=self.lb.yview); sb.pack(side="right",fill="y")
        self.lb.config(yscrollcommand=sb.set)

        cf = ttk.LabelFrame(self, text="‚ûï Custom ID"); cf.pack(fill="x", padx=pad)
        self.e_custom = ttk.Entry(cf); self.e_custom.pack(side="left",fill="x",expand=True,padx=pad)
        ttk.Button(cf, text="Add", command=self.add_custom).pack(side="right",padx=pad)

        bf = ttk.Frame(self); bf.pack(fill="x",padx=pad,pady=pad)
        self.btn_load = ttk.Button(bf,text="Load UGCs (first token)",command=self.load_ugcs); self.btn_load.pack(side="left",padx=pad)
        self.btn_love = ttk.Button(bf,text="Send LoveIt",state="disabled",command=self.start_worker); self.btn_love.pack(side="left",padx=pad)

        self.prog = ttk.Progressbar(self,maximum=100); self.prog.pack(fill="x",padx=pad)
        self.log  = ScrolledText(self, height=8, state="disabled", bg="#000000", fg="#ffffff", insertbackground="#ffffff")
        self.log.pack(fill="both",expand=True,padx=pad,pady=pad)

    def login_click(self):
        u,p,c = self.e_user.get().strip(), self.e_pw.get().strip(), self.e_cty.get().strip().upper()
        if not all([u,p,c]): return messagebox.showwarning("Input","Missing fields")
        try:
            info = login(u,p,c)
            shared_tokens.append(info); self.tok_var.set(f"Tokens: {len(shared_tokens)}")
            messagebox.showinfo("Login","Token saved")
        except Exception as e:
            messagebox.showerror("Login",str(e))

    def load_tokens(self):
        fp = filedialog.askopenfilename(title="tokens.json",filetypes=[("JSON","*.json")])
        if fp:
            try:
                data=json.load(open(fp,encoding="utf-8"))
                if isinstance(data,list):
                    shared_tokens.extend(data); self.tok_var.set(f"Tokens: {len(shared_tokens)}")
            except Exception as e:
                messagebox.showerror("tokens.json", str(e))

    def load_ugcs(self):
        if not shared_tokens: return
        tok=shared_tokens[0]
        try:
            self.ugcs=load_ugcs(tok["access_token"],tok["profile_id"])
        except Exception as e:
            return messagebox.showerror("UGCs",str(e))
        self.lb.delete(0,tk.END); [self.lb.insert(tk.END,f"{u['id']} | {u.get('title','')}") for u in self.ugcs]
        self.btn_love["state"]="normal"

    def add_custom(self):
        ids=[i for i in self.e_custom.get().replace(",", " ").split() if i]
        self.e_custom.delete(0,tk.END)
        for i in ids:
            if not any(u["id"]==i for u in self.ugcs):
                self.ugcs.append({"id":i}); self.lb.insert(tk.END,f"{i} | Custom")

    def start_worker(self):
        sel=[self.ugcs[i] for i in self.lb.curselection()]
        if not sel: return
        total=len(sel)*len(shared_tokens)
        self.prog.config(maximum=total,value=0)
        self.log.config(state="normal"); self.log.delete("1.0",tk.END); self.log.config(state="disabled")
        self.btn_love["state"]="disabled"
        threading.Thread(target=self.worker,args=(sel,total),daemon=True).start()

    def worker(self,sel,total):
        done=0
        for tok in shared_tokens:
            for u in sel:
                ok=loveit(tok["access_token"],tok["profile_id"],u["id"])
                self.log_q.put(f"[{'OK' if ok else 'FAIL'}] {u['id']}"); done+=1; self.prog_q.put(done)
        self.log_q.put("Finished"); self.prog_q.put(-1)

    def _poll(self):
        while not self.log_q.empty(): self._append(self.log_q.get())
        while not self.prog_q.empty():
            v=self.prog_q.get()
            if v==-1: self.btn_love["state"]="normal"
            else: self.prog["value"]=v
        self.after(100,self._poll)

    def _append(self,txt):
        self.log.config(state="normal"); self.log.insert(tk.END,txt+"\n"); self.log.see(tk.END); self.log.config(state="disabled")

# -------------------- Token Runner Tab --------------------
class TokenRunnerTab(ttk.Frame):
    LOGIN_URL    = "https://eu-secure.mspapis.com/loginidentity/connect/token"
    ACCOUNTS_FILE = "token.txt"     # <- LOKALE Datei mit user:pass:country
    PROXIES_FILE  = "proxies.txt"   # <- LOKALE Datei mit user:pass@host:port

    def __init__(self, master):
        super().__init__(master)
        self.running = False
        self.success = 0

        # Round-robin Proxies
        self.proxies = []
        self.proxy_idx = 0
        self.proxy_lock = threading.Lock()

        self.thread_count = tk.IntVar(value=3)
        self.delay_seconds = tk.IntVar(value=3)

        self._build()
        self._load_proxies()
        self._load_accounts()

    # ---------- UI ----------
    def _build(self):
        pad = 6

        top = ttk.Frame(self)
        top.pack(fill="x", padx=pad, pady=pad)

        self.btn = ttk.Button(top, text="Start", command=self.toggle)
        self.btn.pack(side="left", padx=pad)

        ttk.Button(top, text="üîÑ Proxies neu laden", command=self._load_proxies).pack(side="left", padx=pad)
        ttk.Button(top, text="üìÑ Accounts neu laden", command=self._load_accounts).pack(side="left", padx=pad)
        ttk.Button(top, text="Manual", command=self.manual_win).pack(side="left", padx=pad)

        self.lbl = ttk.Label(self, text="OK Tokens: 0", foreground="lightgreen")
        self.lbl.pack()

        tf = ttk.Frame(self)
        tf.pack(fill="x", padx=pad)

        ttk.Label(tf, text="Threads:").pack(side="left", padx=pad)
        ttk.Spinbox(tf, from_=1, to=50, textvariable=self.thread_count, width=5).pack(side="left")

        ttk.Label(tf, text="Delay (s):").pack(side="left", padx=pad)
        ttk.Spinbox(tf, from_=0, to=10, textvariable=self.delay_seconds, width=5).pack(side="left")

        self.log = ScrolledText(self, height=15, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

        # kleine Statuslabels
        stat = ttk.Frame(self); stat.pack(fill="x", padx=pad, pady=(0, pad))
        self.acc_count_var = tk.StringVar(value="Accounts: 0")
        self.prx_count_var = tk.StringVar(value="Proxies: 0")
        ttk.Label(stat, textvariable=self.acc_count_var).pack(side="left")
        ttk.Label(stat, textvariable=self.prx_count_var).pack(side="left", padx=12)

    # ---------- Logging ----------
    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

    def inc_ok(self):
        self.success += 1
        self.lbl.config(text=f"OK Tokens: {self.success}")

    # ---------- Daten laden ----------
    def _base_dir(self):
        return os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)

    def _load_proxies(self):
        path = os.path.join(self._base_dir(), self.PROXIES_FILE)
        self.proxies.clear()
        try:
            with open(path, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue
                    # Erwartetes Format: user:pass@host:port (dein Beispiel)
                    # z.B. user-NiveDev:Pwd@eu.lunaproxy.com:12233
                    if "@" in line and ":" in line:
                        # baue http(s) Proxy-URL
                        proxy_url = f"http://{line}"
                        self.proxies.append({"http": proxy_url, "https": proxy_url})
            self.prx_count_var.set(f"Proxies: {len(self.proxies)}")
            self.write(f"[proxies] geladen: {len(self.proxies)}", "cyan")
        except Exception as e:
            self.write(f"[proxies] Fehler beim Laden: {e}", "red")
            self.prx_count_var.set("Proxies: 0")

    def _load_accounts(self):
        self.accounts = []  # Liste von Tupeln (user, pass, country)
        path = os.path.join(self._base_dir(), self.ACCOUNTS_FILE)
        try:
            with open(path, "r", encoding="utf-8") as f:
                for line in f:
                    l = line.strip()
                    if not l or l.startswith("#"):
                        continue
                    parts = l.split(":")
                    if len(parts) == 1:
                        # nur username -> kein pass, skip
                        continue
                    if len(parts) == 2:
                        user, pw = parts
                        ctry = "de"
                    else:
                        user, pw, ctry = parts[0], parts[1], (parts[2] or "de")
                    self.accounts.append((user.strip(), pw.strip(), ctry.strip().lower()))
            self.acc_count_var.set(f"Accounts: {len(self.accounts)}")
            self.write(f"[accounts] geladen: {len(self.accounts)}", "cyan")
        except FileNotFoundError:
            self.write(f"[accounts] {self.ACCOUNTS_FILE} nicht gefunden", "red")
            self.acc_count_var.set("Accounts: 0")
        except Exception as e:
            self.write(f"[accounts] Fehler beim Laden: {e}", "red")
            self.acc_count_var.set("Accounts: 0")

    # ---------- Proxy RR ----------
    def _next_proxy(self):
        if not self.proxies:
            return None
        with self.proxy_lock:
            prx = self.proxies[self.proxy_idx % len(self.proxies)]
            self.proxy_idx += 1
            return prx

    # ---------- Worker ----------
    def worker(self, q: queue.Queue):
        timeout_streak = 0
        while self.running:
            try:
                u, p, c = q.get_nowait()
            except queue.Empty:
                break

            try:
                prx = self._next_proxy()
                info = login(u, p, c, proxies=prx)  # dein vorhandenes login() nutzt proxies=
                shared_tokens.append(info)
                self.write(f"[OK] {u}", "green")
                self.inc_ok()
                timeout_streak = 0
                time.sleep(self.delay_seconds.get())
            except requests.exceptions.Timeout:
                timeout_streak += 1
                self.write(f"[TIMEOUT] {u}", "orange")
                if timeout_streak >= 7:
                    self.write("[INFO] 7x Timeout ‚Üí Warte 30 Sekunden...", "yellow")
                    time.sleep(120)
                    timeout_streak = 0
            except Exception as e:
                self.write(f"[FAIL] {u} ({e})", "red")
                timeout_streak = 0

            q.task_done()

    # ---------- Start/Stop ----------
    def toggle(self):
        self.running = not self.running
        self.btn.config(text="Stop" if self.running else "Start")
        if not self.running:
            return

        if not getattr(self, "accounts", None):
            self._load_accounts()
        if not self.accounts:
            self.write("[WARN] Keine Accounts geladen.", "yellow")
            self.running = False
            self.btn.config(text="Start")
            return

        q = queue.Queue()
        for a in self.accounts:
            q.put(a)

        for _ in range(self.thread_count.get()):
            threading.Thread(target=self.worker, args=(q,), daemon=True).start()

    # ---------- Manual Login ----------
    def manual_win(self):
        w = tk.Toplevel(self)
        w.title("Manual")
        w.geometry("260x200")

        ttk.Label(w, text="User").pack()
        e_u = ttk.Entry(w); e_u.pack()

        ttk.Label(w, text="Pass").pack()
        e_p = ttk.Entry(w, show="*"); e_p.pack()

        ttk.Label(w, text="Country").pack()
        e_c = ttk.Entry(w); e_c.insert(0, "de"); e_c.pack()

        def run():
            try:
                prx = self._next_proxy()
                info = login(e_u.get(), e_p.get(), e_c.get(), proxies=prx)
                shared_tokens.append(info)
                self.write("[OK] manual", "green")
                self.inc_ok()
            except Exception as e:
                self.write(f"[FAIL] manual ({e})", "red")
            w.destroy()

        ttk.Button(w, text="Login", command=run).pack(pady=8)

# -------------------- Gender Switch Tab --------------------
class GenderSwitchTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.token_info = None
        self.scraper = cloudscraper.create_scraper()
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login"); lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0,"DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        self.gender_var = tk.StringVar(value="Geschlecht: Unbekannt")
        ttk.Label(self, textvariable=self.gender_var).pack(pady=pad)

        ttk.Button(self, text="üîÑ Geschlecht wechseln", command=self.toggle_gender).pack(pady=pad)

        self.log = ScrolledText(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")

        try:
            self.token_info = login(u, p, c)  # liefert access_token + profile_id
            gender = self.get_gender()
            self.gender_var.set(f"Geschlecht: {gender}")
            self.write(f"[OK] Eingeloggt als {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def get_gender(self):
        url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{self.token_info['profile_id']}/games/j68d/attributes"
        headers = {
            "Authorization": f"Bearer {self.token_info['access_token']}",
            "Accept": "application/json"
        }
        r = self.scraper.get(url, headers=headers)
        r.raise_for_status()
        data = r.json()
        return data.get("additionalData", {}).get("Gender", "Unbekannt")

    def toggle_gender(self):
        if not self.token_info:
            return messagebox.showwarning("Nicht eingeloggt", "Bitte zuerst einloggen.")

        try:
            url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{self.token_info['profile_id']}/games/j68d/attributes"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Accept": "application/json"
            }

            # Aktuellen Status abrufen
            r = self.scraper.get(url, headers=headers)
            r.raise_for_status()
            data = r.json()

            current_gender = data["additionalData"].get("Gender", "Boy")
            new_gender = "Girl" if current_gender == "Boy" else "Boy"
            data["additionalData"]["Gender"] = new_gender

            headers["Content-Type"] = "application/json"
            put = self.scraper.put(url, headers=headers, json=data)
            put.raise_for_status()

            self.gender_var.set(f"Geschlecht: {new_gender}")
            self.write(f"[OK] Geschlecht ge√§ndert zu {new_gender}", "green")
            self.write(f"Logge dich neu ein!", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Fehler", str(e))

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

# -------------------- Autograph Tab --------------------
class AutographTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.accounts = []
        self.scraper = cloudscraper.create_scraper()
        self.auto_running = False
        self.auto_thread = None
        self._build()
        self._start_token_refresh_thread()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf)
        self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*")
        self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf)
        self.e_cty.insert(0, "DE")
        self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)
        ttk.Button(lf, text="üìú ListeLogin", command=lambda: self.login_from_file("autograph.txt")).grid(row=4, columnspan=2, pady=(0, pad))
        ttk.Button(lf, text="üìú ListeLogin2", command=lambda: self.login_from_file("autograph2.txt")).grid(row=5, columnspan=2, pady=(0, pad))

        self.account_list = tk.Listbox(self, height=4, bg="#000000", fg="white", selectbackground="#000000", selectforeground="white")
        self.account_list.pack(fill="x", padx=pad, pady=(pad, 0))

        ttk.Button(self, text="‚ùå Entfernen", command=self.remove_selected_account).pack(pady=(0, pad))

        targetf = ttk.LabelFrame(self, text="Autogramm senden an:")
        targetf.pack(fill="x", padx=pad, pady=pad)

        self.e_target = ttk.Entry(targetf)
        self.e_target.pack(fill="x", padx=pad, pady=pad)

        ttk.Button(self, text="‚ñ∂Ô∏è Start", command=self.start_auto).pack(pady=pad)
        ttk.Button(self, text="‚èπÔ∏è Stop", command=self.stop_auto).pack(pady=(0, pad))

        self.log = ScrolledText(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_from_file(self, filename):
        try:
            base_dir = os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)
            full_path = os.path.join(base_dir, filename)
            self.write(f"[DEBUG] Suche Datei: {full_path}", "yellow")

            with open(full_path, "r", encoding="utf-8") as f:
                lines = f.readlines()

            for line in lines:
                parts = line.strip().split(":")
                if len(parts) < 2:
                    continue
                u = parts[0].strip()
                p = parts[1].strip()
                c = parts[2].strip().upper() if len(parts) > 2 else "DE"
                try:
                    token_info = login(u, p, c)
                    token_info["username"] = u
                    token_info["password"] = p
                    token_info["country"] = c
                    self.accounts.append(token_info)
                    self.account_list.insert(tk.END, u)
                    self.write(f"[OK] Eingeloggt als {u}", "green")
                except Exception as e:
                    self.write(f"[FEHLER] {u}: {e}", "red")

        except Exception as e:
            self.write(f"[FEHLER] Datei konnte nicht gelesen werden: {e}", "red")

    def remove_selected_account(self):
        selected = self.account_list.curselection()
        if not selected:
            return
        index = selected[0]
        acc = self.accounts[index]
        self.write(f"[INFO] Account entfernt: {acc['username']}", "yellow")
        self.account_list.delete(index)
        del self.accounts[index]

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        if int(self.log.index("end-1c").split(".")[0]) > 50:
            self.log.delete("1.0", "2.0")
        self.log.see(tk.END)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")
        try:
            token_info = login(u, p, c)
            token_info["username"] = u
            token_info["password"] = p
            token_info["country"] = c
            self.accounts.append(token_info)
            self.account_list.insert(tk.END, u)
            self.write(f"[OK] Eingeloggt als {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def find_profile_id(self, username, region):
        try:
            url = "https://eu.mspapis.com/edgerelationships/graphql/graphql"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Content-Type": "application/json"
            }
            query = """
            query GetProfileSearch($region: String!, $startsWith: String!, $pageSize: Int, $currentPage: Int, $preferredGameId: String!) {
                findProfiles(region: $region, nameBeginsWith: $startsWith, pageSize: $pageSize, page: $currentPage) {
                    totalCount
                    nodes {
                        id
                        avatar(preferredGameId: $preferredGameId) {
                            gameId
                            face
                            full
                        }
                    }
                }
            }
            """
            variables = {
                "region": region,
                "startsWith": username,
                "pageSize": 50,
                "currentPage": 1,
                "preferredGameId": "j68d"
            }
            payload = {"query": query, "variables": variables}
            r = self.scraper.post(url, headers=headers, json=payload)
            r.raise_for_status()
            data = r.json()
            nodes = data.get("data", {}).get("findProfiles", {}).get("nodes", [])
            if not nodes:
                self.write(f"[FEHLER] Kein Profil mit dem Namen '{username}' gefunden.", "red")
                return None
            return nodes[0]["id"]
        except Exception as e:
            self.write(f"[FEHLER] Profil-ID konnte nicht ermittelt werden: {e}", "red")
            return None

    def send_autograph(self, token_info, receiver_id, target_name):
        try:
            url = "https://eu.mspapis.com/federationgateway/graphql"
            headers = {
                "Authorization": f"Bearer {token_info['access_token']}",
                "Content-Type": "application/json"
            }
            payload = {
                "id": "SendGreetings-159BDD7706D824BB8F14874A7FAE3368",
                "variables": {
                    "greetingType": "Autograph",
                    "receiverProfileId": receiver_id,
                    "ignoreDailyCap": False
                }
            }
            r = self.scraper.post(url, headers=headers, json=payload)
            r.raise_for_status()
            data = r.json()
            success = data.get("data", {}).get("greetings", {}).get("sendGreeting", {}).get("success", False)
            if success:
                self.write(f"[OK] Autogramm an {target_name} gesendet von {token_info['username']}", "green")
            else:
                self.write(f"[FEHLER] Autogramm von {token_info['username']} konnte nicht gesendet werden", "red")
        except Exception as e:
            self.write(f"[FEHLER] {token_info['username']}: {e}", "red")

    def start_auto(self):
        if not self.accounts:
            return messagebox.showwarning("Keine Accounts", "Bitte mindestens einen Account anmelden.")
        if not self.e_target.get().strip():
            return messagebox.showwarning("Fehler", "Zielbenutzer eingeben!")

        self.auto_running = True
        self.auto_thread = threading.Thread(target=self.auto_loop, daemon=True)
        self.auto_thread.start()
        self.write("[INFO] Automatisches Versenden gestartet...", "green")

    def stop_auto(self):
        self.auto_running = False
        self.write("[INFO] Automatisches Versenden gestoppt.", "yellow")

    def auto_loop(self):
        def send_loop(acc):
            last_target_name = None
            last_profile_id = None

            while self.auto_running:
                target_name = self.e_target.get().strip()
                if not target_name:
                    self.write("[FEHLER] Kein Zielbenutzer gesetzt.", "red")
                    break

                if target_name != last_target_name:
                    self.token_info = acc
                    profile_id = self.find_profile_id(target_name, acc["country"])
                    if profile_id:
                        last_profile_id = profile_id
                        last_target_name = target_name
                    else:
                        last_profile_id = None  # Reset if not found

                if last_profile_id:
                    self.send_autograph(acc, last_profile_id, last_target_name)

                for _ in range(123):  # 2 Minuten warten
                    if not self.auto_running:
                        break
                    time.sleep(1)

        for acc in self.accounts:
            threading.Thread(target=send_loop, args=(acc,), daemon=True).start()


    def _start_token_refresh_thread(self):
        def refresh_loop():
            while True:
                time.sleep(3600)
                for i, acc in enumerate(self.accounts):
                    try:
                        new_token = login(acc["username"], acc["password"], acc["country"])
                        new_token["username"] = acc["username"]
                        new_token["password"] = acc["password"]
                        new_token["country"] = acc["country"]
                        self.accounts[i].update(new_token)
                        self.write(f"[REFRESH] Token erneuert f√ºr {acc['username']}", "cyan")
                    except Exception as e:
                        self.write(f"[FEHLER] Token-Erneuerung fehlgeschlagen f√ºr {acc['username']}: {e}", "red")
        threading.Thread(target=refresh_loop, daemon=True).start()

# -------------------- Duplication Tool (Fix mit Datum + Gift-Liste + 4x Login) --------------------
class GiftOpenerTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.accounts = []
        self.threads = []
        self.start_event = threading.Event()
        self._build()

    def _build(self):
        pad = 6

        lf = ttk.LabelFrame(self, text="Logins einzeln")
        lf.pack(fill="x", padx=pad, pady=pad)

        for i in range(2):
            ttk.Label(lf, text=f"Benutzer {i+1}").grid(row=i*4, column=0, sticky="w")
            setattr(self, f"e_user{i}", ttk.Entry(lf))
            getattr(self, f"e_user{i}").grid(row=i*4, column=1, padx=pad)

            ttk.Label(lf, text="Passwort").grid(row=i*4+1, column=0, sticky="w")
            setattr(self, f"e_pw{i}", ttk.Entry(lf, show="*"))
            getattr(self, f"e_pw{i}").grid(row=i*4+1, column=1, padx=pad)

            ttk.Label(lf, text="Land").grid(row=i*4+2, column=0, sticky="w")
            e_cty = ttk.Entry(lf)
            e_cty.insert(0, "DE")
            setattr(self, f"e_cty{i}", e_cty)
            e_cty.grid(row=i*4+2, column=1, padx=pad)

            ttk.Button(lf, text=f"Login Benutzer {i+1}", command=lambda idx=i: self.login_click(idx)).grid(row=i*4+3, columnspan=2, pady=pad)

        gf = ttk.LabelFrame(self, text="üéÅ Geschenk √∂ffnen")
        gf.pack(fill="x", padx=pad, pady=pad)

        for i in range(2):
            ttk.Label(gf, text=f"Gift-ID f√ºr Benutzer {i+1}").grid(row=i, column=0)
            setattr(self, f"e_gift{i}", ttk.Entry(gf))
            getattr(self, f"e_gift{i}").grid(row=i, column=1, padx=pad)

        ttk.Button(self, text="üß† Threads vorbereiten", command=self.open_gifts).pack(pady=pad)
        ttk.Button(self, text="üéØ Jetzt starten", command=self.start_event.set).pack(pady=pad)

        self.log = tk.Text(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self, idx):
        u = getattr(self, f"e_user{idx}").get().strip()
        p = getattr(self, f"e_pw{idx}").get().strip()
        c = getattr(self, f"e_cty{idx}").get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")

        try:
            for i in range(2):  # doppelt einloggen
                token_info = login(u, p, c)
                token_info["username"] = u
                token_info["country"] = c
                self.accounts.append(token_info)
            self.write(f"[OK] Benutzer {idx+1} doppelt eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login Benutzer {idx+1}: {e}", "red")
            messagebox.showerror("Login", str(e))

    def open_gifts(self):
        self.threads.clear()
        self.start_event.clear()

        for idx in range(len(self.accounts)):
            for _ in range(10):  # volle Power pro Session
                t = threading.Thread(target=self.open_single_gift, args=(idx,), daemon=True)
                self.threads.append(t)

        for t in self.threads:
            t.start()

        self.write("[INFO] Alle Threads bereit. Warte auf Startsignal...", "yellow")

    def open_single_gift(self, idx):
        acc = self.accounts[idx]
        if not acc:
            self.write(f"[FEHLER] Benutzer {idx+1} nicht eingeloggt", "red")
            return

        gift_id_index = 0 if idx < 2 else idx % 2
        gift_id = getattr(self, f"e_gift{gift_id_index}").get().strip()

        if not gift_id:
            self.write(f"[FEHLER] Keine Gift-ID f√ºr Benutzer {gift_id_index+1} angegeben", "red")
            return

        self.start_event.wait()  # Synchronstart

        payload = {
            "query": """
            mutation OpenGift($giftId: ID!, $receiverProfileId: ID!) {
                openGift(input: { giftId: $giftId, receiverProfileId: $receiverProfileId }) {
                    success
                    error
                    item {
                        id objectId objectSource additionalData
                        tags { id source }
                    }
                }
            }
            """,
            "variables": {
                "giftId": gift_id,
                "receiverProfileId": acc["profile_id"]
            }
        }

        headers = {
            "Authorization": f"Bearer {acc['access_token']}",
            "Content-Type": "application/json",
            "Referer": "https://moviestarplanet2.com/",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
        }

        try:
            res = self.scraper.post("https://eu.mspapis.com/edgegifts/graphql/graphql",
                                    headers=headers, json=payload, timeout=6)
            res.raise_for_status()
            data = res.json()["data"]["openGift"]

            if data["success"]:
                item_id = data["item"]["id"]
                self.after(0, self.write, f"[OK] Geschenk {gift_id} ge√∂ffnet f√ºr {acc['username']} (Item ID: {item_id})", "green")
            else:
                error = data["error"]
                self.after(0, self.write, f"[FEHLER] Geschenk nicht ge√∂ffnet f√ºr {acc['username']}: {error}", "red")
        except Exception as e:
            self.after(0, self.write, f"[FEHLER] Fehler bei {acc['username']}: {e}", "red")

    def write(self, msg, color=None):
        self.log.insert(tk.END, msg + "\n")
        self.log.see(tk.END)

# -------------------- Daily Login --------------------
class DailyLogin(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.accounts = []
        self._build()

    def _build(self):
        pad = 6

        ttk.Label(self, text="üìÑ Accountliste ausw√§hlen").pack(pady=(8, 2))
        self.combo_claim = ttk.Combobox(
            self, values=["1", "2", "3", "4", "5", "6", "7"], state="readonly", width=5)
        self.combo_claim.set("1")
        self.combo_claim.pack()

        ttk.Button(self, text="üìú Liste einloggen", command=self.login_from_file).pack(pady=(4, pad))

        self.log = tk.Text(self, height=16, bg="#000000", fg="white", insertbackground="#ffffff")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_from_file(self):
        file_id = self.combo_claim.get()
        suffix = '' if file_id == '1' else file_id
        dateiname = resource_path(f"acclist{suffix}.txt")

        # ‚Üí holt den Pfad der EXE oder des Skripts
        base_dir = os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)
        dateiname = os.path.join(base_dir, f"acclist{suffix}.txt")

        # üëá Debug-Ausgabe f√ºr den gesuchten Dateipfad
        self.write(f"[DEBUG] Suche Datei: {dateiname}", "yellow")

        def worker():
            try:
                with open(dateiname, "r", encoding="utf-8") as f:
                    lines = [line.strip() for line in f if line.strip()]
                for line in lines:
                    parts = line.split(":")
                    if len(parts) < 2:
                        continue
                    u, p = parts[0], parts[1]
                    c = parts[2] if len(parts) >= 3 else "DE"
                    try:
                        scraper = cloudscraper.create_scraper()
                        token_info = login(u, p, c, proxies=scraper.proxies)
                        token_info["username"] = u
                        self.accounts.append(token_info)
                        self.write(f"[Login] {u}", "green")
                    except Exception as e:
                        self.write(f"[FEHLER] {u}: {e}", "red")
                    time.sleep(0.5)
                self.write("‚úÖ Liste abgeschlossen. Weitere Liste nur manuell starten.", "cyan")
            except Exception as e:
                self.write(f"[FEHLER] Datei: {e}", "red")

        threading.Thread(target=worker, daemon=True).start()

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_configure(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)


# -------------------- Teleport Tab --------------------
class TeleportTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.token_info = None
        self.scraper = cloudscraper.create_scraper()
        self.attributes = {}
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf)
        self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*")
        self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf)
        self.e_cty.insert(0, "DE")
        self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        pos_frame = ttk.LabelFrame(self, text="Neue Koordinaten")
        pos_frame.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(pos_frame, text="X").grid(row=0, column=0)
        self.e_x_int = ttk.Entry(pos_frame, width=5)
        self.e_x_int.insert(0, "15")
        self.e_x_int.grid(row=0, column=1, padx=4)

        ttk.Label(pos_frame, text="Y").grid(row=0, column=2)
        self.e_y_int = ttk.Entry(pos_frame, width=5)
        self.e_y_int.insert(0, "-1")
        self.e_y_int.grid(row=0, column=3, padx=4)

        ttk.Label(pos_frame, text="Z").grid(row=0, column=4)
        self.e_z_int = ttk.Entry(pos_frame, width=5)
        self.e_z_int.insert(0, "-16")
        self.e_z_int.grid(row=0, column=5, padx=4)

        ttk.Label(self, text="üåç Raumtyp w√§hlen").pack(pady=(4, 0))
        self.room_type = ttk.Combobox(self, state="readonly", values=[
            "basic_plaza",
            "forest",
            "basic_beach",
            "basic_vip"
        ])
        self.room_type.set("basic_plaza")
        self.room_type.pack(pady=(0, pad))

        ttk.Button(self, text="üõ∞Ô∏è Teleportieren", command=self.teleport).pack(pady=pad)

        self.log = ScrolledText(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")

        try:
            self.token_info = login(u, p, c)
            self.token_info["username"] = u
            self.write(f"[OK] Eingeloggt als {u}", "green")
            self.load_attributes()
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def load_attributes(self):
        profile_id = self.token_info['profile_id']
        token = self.token_info['access_token']
        url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{profile_id}/games/j68d/attributes"
        headers = {
            "Authorization": f"Bearer {token}",
            "Accept": "application/json"
        }
        try:
            r = self.scraper.get(url, headers=headers)
            r.raise_for_status()
            data = r.json()
            self.attributes = data.get("additionalData", {})
            self.write("[INFO] Daten erfolgreich geladen.", "cyan")
        except Exception as e:
            self.write(f"[FEHLER] Daten konnten nicht geladen werden: {e}", "red")

    def teleport(self):
        if not self.token_info or not self.attributes:
            return messagebox.showwarning("Fehler", "Bitte zuerst einloggen und Daten laden.")

        try:
            # Sichtbare Eingaben
            x_int = int(self.e_x_int.get())
            y_int = int(self.e_y_int.get())
            z_int = int(self.e_z_int.get())

            # Fest hinterlegte Nachkommastellen
            x_float = float(f"{x_int}.83926010131836")
            y_float = float(f"{y_int}.5668649077415466")
            z_float = float(f"{z_int}.73294997215271")

        except ValueError:
            return messagebox.showerror("Fehler", "Ung√ºltige Zahlen (nur ganze Zahlen erlaubt).")

        try:
            profile_id = self.token_info['profile_id']
            token = self.token_info['access_token']
            url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{profile_id}/games/j68d/attributes"
            headers = {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            }

            payload = {
                "additionalData": dict(self.attributes)
            }

            pos_data = json.loads(payload["additionalData"].get("ChatRoomPositionData", "{}"))
            pos_data["position"] = {"x": x_float, "y": y_float, "z": z_float}
            pos_data["roomType"] = self.room_type.get()
            payload["additionalData"]["ChatRoomPositionData"] = json.dumps(pos_data)

            res = self.scraper.put(url, headers=headers, json=payload)
            if res.status_code == 200:
                self.write(f"[OK] Teleportiert nach {self.room_type.get()} ‚Üí X:{x_float} Y:{y_float} Z:{z_float}", "green")
            else:
                self.write(f"[FEHLER] Teleport fehlgeschlagen: {res.status_code}", "red")
        except Exception as e:
            self.write(f"[FEHLER] Teleport fehlgeschlagen: {e}", "red")

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_configure(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)


# -------------------- Star Greeting Combo Tab --------------------
class StarGreetingComboTab(ttk.Frame):
    """
    Kombi-Tool mit animiertem Toggle:
      0 = Viele Accounts -> 1 Empf√§nger (StarGreeting alle 15 min)
      1 = Ein Account    -> Viele Empf√§nger (StarGreeting alle 15 min)
    """
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()

        # Gemeinsame States
        self.auto_running = False
        self.loop_thread  = None
        self.current_mode = 0  # 0 = MS->ST, 1 = SM->MT

        # --- Mode 0 (multi -> single) ---
        self.ms_accounts = []    # dicts mit access_token, username, password, country
        self.ms_token_refresh_thread = None

        # --- Mode 1 (single -> multi) ---
        self.sm_account   = None
        self.sm_targets   = []
        self.sm_token_refresh_thread = None

        self._build()
        self._start_token_refresh_threads()

    # ---------------- UI ----------------
    def _build(self):
        pad = 6

        # Modus-Umschalter (klein & animiert)
        mf = ttk.LabelFrame(self, text="Modus")
        mf.pack(fill="x", padx=pad, pady=(pad, 0))

        self.mode_label = ttk.Label(mf, text="Viele Accounts ‚Üí 1 Empf√§nger")
        self.mode_label.pack(side="right", padx=pad)

        # Wichtig: on_toggle ruft NUR _apply_mode (keine programmatic set-Calls!)
        def _on_toggle(is_on: bool):
            self._apply_mode(1 if is_on else 0)

        self.mode_switch = AnimatedToggleSwitch(mf, value=False, on_toggle=_on_toggle, width=44, height=24)
        self.mode_switch.pack(side="left", padx=pad, pady=(4, 4))

        # Container f√ºr beide Modi
        self.container = ttk.Frame(self)
        self.container.pack(fill="both", expand=True, padx=pad, pady=pad)

        # --------- Mode 0 UI  (Viele -> Ein) ---------
        self.frame_ms = ttk.Frame(self.container)

        lf = ttk.LabelFrame(self.frame_ms, text="Login (mehrere Accounts)")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.ms_e_user = ttk.Entry(lf); self.ms_e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.ms_e_pw = ttk.Entry(lf, show="*"); self.ms_e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.ms_e_cty = ttk.Entry(lf); self.ms_e_cty.insert(0, "DE")
        self.ms_e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.ms_login_click).grid(row=3, columnspan=2, pady=(pad, 0))

        # (ENTFERNT) ListeLogin-Buttons

        self.ms_list = tk.Listbox(self.frame_ms, height=5, bg="#000000", fg="white",
                                  selectbackground="#000000", selectforeground="white")
        self.ms_list.pack(fill="x", padx=pad, pady=(0, 2))

        ttk.Button(self.frame_ms, text="‚ùå Ausgew√§hlten Account entfernen", command=self.ms_remove_selected).pack(padx=pad, pady=(0, pad))

        tf = ttk.LabelFrame(self.frame_ms, text="Empf√§nger (Name oder profileId)")
        tf.pack(fill="x", padx=pad, pady=pad)
        self.ms_e_target = ttk.Entry(tf)
        self.ms_e_target.pack(fill="x", padx=pad, pady=(pad, 2))
        self.ms_var_target_is_id = tk.BooleanVar(value=False)
        ttk.Checkbutton(tf, text="Eingabe ist bereits profileId",
                        variable=self.ms_var_target_is_id).pack(anchor="w", padx=pad)

        ctl = ttk.Frame(self.frame_ms); ctl.pack(fill="x", padx=pad, pady=(pad, 0))
        ttk.Button(ctl, text="‚ñ∂Ô∏è Start (alle 15 Min.)", command=self.start_loop).pack(side="left")
        ttk.Button(ctl, text="‚èπÔ∏è Stop", command=self.stop_loop).pack(side="left", padx=(pad, 0))

        # --------- Mode 1 UI  (Ein -> Viele) ---------
        self.frame_sm = ttk.Frame(self.container)

        lfs = ttk.LabelFrame(self.frame_sm, text="Login (ein Account)")
        lfs.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lfs, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.sm_e_user = ttk.Entry(lfs); self.sm_e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lfs, text="Passwort").grid(row=1, column=0, sticky="w")
        self.sm_e_pw = ttk.Entry(lfs, show="*"); self.sm_e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lfs, text="Land").grid(row=2, column=0, sticky="w")
        self.sm_e_cty = ttk.Entry(lfs); self.sm_e_cty.insert(0, "DE")
        self.sm_e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lfs, text="Anmelden", command=self.sm_login_click).grid(row=3, columnspan=2, pady=(pad, 0))

        tgtf = ttk.LabelFrame(self.frame_sm, text="Empf√§nger verwalten")
        tgtf.pack(fill="both", padx=pad, pady=pad)

        row = ttk.Frame(tgtf); row.pack(fill="x", padx=pad, pady=(pad, 2))
        ttk.Label(row, text="Empf√§nger (Name oder profileId):").pack(side="left")
        self.sm_e_add = ttk.Entry(row); self.sm_e_add.pack(side="left", fill="x", expand=True, padx=(6, 6))
        ttk.Button(row, text="‚ûï Hinzuf√ºgen", command=self.sm_add_target).pack(side="left")

        self.sm_listbox = tk.Listbox(tgtf, height=6, bg="#000000", fg="white",
                                     selectbackground="#333333", selectforeground="white")
        self.sm_listbox.pack(fill="both", expand=True, padx=pad, pady=(2, 2))

        row2 = ttk.Frame(tgtf); row2.pack(fill="x", padx=pad, pady=(0, pad))
        ttk.Button(row2, text="‚ùå Entfernen", command=self.sm_remove_selected).pack(side="left")
        ttk.Button(row2, text="üßπ Leeren", command=self.sm_clear_list).pack(side="left", padx=(pad, 0))
        self.sm_var_targets_are_ids = tk.BooleanVar(value=False)
        ttk.Checkbutton(tgtf, text="Alle Eintr√§ge sind bereits profileIds",
                        variable=self.sm_var_targets_are_ids).pack(anchor="w", padx=pad, pady=(0, 2))

        ctl2 = ttk.Frame(self.frame_sm); ctl2.pack(fill="x", padx=pad, pady=(pad, 0))
        ttk.Button(ctl2, text="‚ñ∂Ô∏è Start (alle 15 Min.)", command=self.start_loop).pack(side="left")
        ttk.Button(ctl2, text="‚èπÔ∏è Stop", command=self.stop_loop).pack(side="left", padx=(pad, 0))

        # --------- Log ----------
        self.log = ScrolledText(self, height=14, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

        # Initiale Ansicht NUR programmatisch setzen (Switch ohne Callback anpassen)
        self._switch_mode(0)

    # --------- Neue Trennung: Anwenden vs. Setzen ----------
    def _apply_mode(self, m: int):
        """Nur Frames/Label aktualisieren, KEIN set() auf dem Switch!"""
        self.current_mode = m
        for child in (self.frame_ms, self.frame_sm):
            child.pack_forget()
        if m == 0:
            self.frame_ms.pack(fill="both", expand=True)
            self.mode_label.config(text="Viele Accounts ‚Üí 1 Empf√§nger")
        else:
            self.frame_sm.pack(fill="both", expand=True)
            self.mode_label.config(text="Ein Account ‚Üí Viele Empf√§nger")

    def _switch_mode(self, m: int):
        """Programmatische Umschaltung: Switch-Status setzen OHNE on_toggle, danach UI anwenden."""
        self.mode_switch.set(m == 1, trigger=False)  # kein Callback feuern
        self._apply_mode(m)

    # ---------------- Helpers / (‚Ä¶ Rest bleibt wie gehabt) ----------------
    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        if int(self.log.index("end-1c").split(".")[0]) > 500:
            self.log.delete("1.0", "120.0")
        self.log.see(tk.END)

    def _looks_like_uuid(self, s: str) -> bool:
        s = s.strip().lower()
        return len(s) == 32 and all(c in "0123456789abcdef" for c in s)

    def _start_token_refresh_threads(self):
        def ms_refresh():
            while True:
                time.sleep(3600)
                for i, acc in enumerate(list(self.ms_accounts)):
                    try:
                        new_token = login(acc["username"], acc["password"], acc["country"])
                        new_token["username"] = acc["username"]
                        new_token["password"] = acc["password"]
                        new_token["country"]  = acc["country"]
                        self.ms_accounts[i] = new_token
                        self.write(f"[REFRESH] Token erneuert f√ºr {acc['username']}", "cyan")
                    except Exception as e:
                        self.write(f"[FEHLER] Token-Refresh (MS) {acc.get('username','?')}: {e}", "red")
        threading.Thread(target=ms_refresh, daemon=True).start()

        def sm_refresh():
            while True:
                time.sleep(3600)
                if not self.sm_account:
                    continue
                try:
                    acc = self.sm_account
                    new_token = login(acc["username"], acc["password"], acc["country"])
                    new_token["username"] = acc["username"]
                    new_token["password"] = acc["password"]
                    new_token["country"]  = acc["country"]
                    self.sm_account = new_token
                    self.write(f"[REFRESH] Token erneuert f√ºr {acc['username']}", "cyan")
                except Exception as e:
                    self.write(f"[FEHLER] Token-Refresh (SM): {e}", "red")
        threading.Thread(target=sm_refresh, daemon=True).start()

    # ---------------- Logins ----------------
    # Mode 0
    def ms_login_click(self):
        u = self.ms_e_user.get().strip()
        p = self.ms_e_pw.get().strip()
        c = self.ms_e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")
        try:
            acc = login(u, p, c)
            acc["username"] = u; acc["password"] = p; acc["country"] = c
            self.ms_accounts.append(acc)
            self.ms_list.insert(tk.END, u)
            self.write(f"[OK] Eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")

    def ms_login_from_file(self, filename):
        try:
            base_dir = os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)
            full_path = os.path.join(base_dir, filename)
            self.write(f"[DEBUG] Lese Datei: {full_path}", "yellow")
            with open(full_path, "r", encoding="utf-8") as f:
                lines = f.readlines()
            added = 0
            for line in lines:
                parts = line.strip().split(":")
                if len(parts) < 2:
                    continue
                u = parts[0].strip()
                p = parts[1].strip()
                c = parts[2].strip().upper() if len(parts) > 2 else "DE"
                try:
                    acc = login(u, p, c)
                    acc["username"] = u; acc["password"] = p; acc["country"] = c
                    self.ms_accounts.append(acc)
                    self.ms_list.insert(tk.END, u)
                    added += 1
                except Exception as e:
                    self.write(f"[FEHLER] {u}: {e}", "red")
            self.write(f"[INFO] {added} Accounts geladen.", "cyan")
        except Exception as e:
            self.write(f"[FEHLER] Datei: {e}", "red")

    def ms_remove_selected(self):
        sel = self.ms_list.curselection()
        if not sel:
            return
        idx = sel[0]
        acc = self.ms_accounts[idx]
        self.ms_list.delete(idx)
        del self.ms_accounts[idx]
        self.write(f"[INFO] Account entfernt: {acc.get('username','?')}", "yellow")

    # Mode 1
    def sm_login_click(self):
        u = self.sm_e_user.get().strip()
        p = self.sm_e_pw.get().strip()
        c = self.sm_e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")
        try:
            acc = login(u, p, c)
            acc["username"] = u; acc["password"] = p; acc["country"] = c
            self.sm_account = acc
            self.write(f"[OK] Eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")

    # Empf√§nger-Management (Mode 1)
    def sm_add_target(self):
        val = self.sm_e_add.get().strip()
        if not val:
            return
        self.sm_listbox.insert(tk.END, val)
        self.sm_e_add.delete(0, tk.END)

    def sm_remove_selected(self):
        sel = self.sm_listbox.curselection()
        if not sel:
            return
        self.sm_listbox.delete(sel[0])

    def sm_clear_list(self):
        self.sm_listbox.delete(0, tk.END)

    # ---------------- API ----------------
    def find_profile_id(self, username, region):
        """
        Sucht die profileId √ºber edgerelationships.findProfiles.
        Verwendet self.token_info['access_token'] (wie von dir gew√ºnscht).
        """
        try:
            if not hasattr(self, "token_info") or not self.token_info or "access_token" not in self.token_info:
                self.write("[FEHLER] Kein Token f√ºr Profilsuche vorhanden (self.token_info fehlt).", "red")
                return None

            name = (username or "").strip()
            if not name:
                self.write("[FEHLER] Leerer Name f√ºr Profilsuche.", "red")
                return None

            url = "https://eu.mspapis.com/edgerelationships/graphql/graphql"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Content-Type": "application/json"
            }
            query = """
            query GetProfileSearch($region: String!, $startsWith: String!, $pageSize: Int, $currentPage: Int, $preferredGameId: String!) {
                findProfiles(region: $region, nameBeginsWith: $startsWith, pageSize: $pageSize, page: $currentPage) {
                    totalCount
                    nodes {
                        id
                        avatar(preferredGameId: $preferredGameId) {
                            gameId
                            face
                            full
                        }
                    }
                }
            }
            """
            variables = {
                "region": region,
                "startsWith": name,
                "pageSize": 50,
                "currentPage": 1,
                "preferredGameId": "j68d"
            }
            payload = {"query": query, "variables": variables}

            r = self.scraper.post(url, headers=headers, json=payload, timeout=15)
            r.raise_for_status()
            data = r.json()
            nodes = data.get("data", {}).get("findProfiles", {}).get("nodes", [])
            if not nodes:
                self.write(f"[FEHLER] Kein Profil mit dem Namen '{name}' gefunden.", "red")
                return None
            return nodes[0]["id"]
        except Exception as e:
            self.write(f"[FEHLER] Profil-ID konnte nicht ermittelt werden: {e}", "red")
            return None

    def send_star_greeting(self, access_token, receiver_profile_id, label):
        try:
            url = "https://eu.mspapis.com/federationgateway/graphql"
            headers = {"Authorization": f"Bearer {access_token}", "Content-Type": "application/json"}
            payload = {
                "id": "SendGreetings-159BDD7706D824BB8F14874A7FAE3368",
                "variables": {
                    "greetingType": "HalloweenGreeting",
                    "receiverProfileId": receiver_profile_id,
                    "ignoreDailyCap": False
                }
            }
            r = self.scraper.post(url, headers=headers, json=payload, timeout=12)
            r.raise_for_status()
            data = r.json()
            success = (
                data.get("data", {}).get("greetings", {}).get("sendGreeting", {}).get("success", False)
            ) or (
                data.get("data", {}).get("sendGreeting", {}).get("success", False)
            )
            if success:
                self.write(f"[OK] StarGreeting ‚Üí {label}", "green")
            else:
                self.write(f"[FEHLER] StarGreeting ‚Üí {label} fehlgeschlagen.", "red")
        except Exception as e:
            self.write(f"[FEHLER] StarGreeting ‚Üí {label}: {e}", "red")

    # ---------------- Loop Control ----------------
    def start_loop(self):
        if self.auto_running:
            return self.write("[INFO] L√§uft bereits.", "yellow")

        m = self.current_mode
        if m == 0:
            # MS ‚Üí ST
            if not self.ms_accounts:
                return messagebox.showwarning("Fehler", "Bitte mindestens einen Account einloggen.")
            if not self.ms_e_target.get().strip():
                return messagebox.showwarning("Fehler", "Empf√§nger angeben!")
        else:
            # SM ‚Üí MT
            if not self.sm_account:
                return messagebox.showwarning("Fehler", "Bitte zuerst einloggen!")
            if self.sm_listbox.size() == 0:
                return messagebox.showwarning("Fehler", "Keine Empf√§nger in der Liste!")

        self.auto_running = True
        self.loop_thread = threading.Thread(target=self._loop, daemon=True)
        self.loop_thread.start()
        self.write("[INFO] Auto-Run gestartet (Intervall 15 Min.)", "cyan")

    def stop_loop(self):
        self.auto_running = False
        self.write("[INFO] Gestoppt.", "yellow")

    def _loop(self):
        INTERVAL = 15 * 60  # 15 Minuten
        while self.auto_running:
            mode_now = self.current_mode
            try:
                if mode_now == 0:
                    self._run_mode_ms()
                else:
                    self._run_mode_sm()
            except Exception as e:
                self.write(f"[FEHLER] Run: {e}", "red")

            # Warten bis n√§chste Runde
            if not self.auto_running:
                break
            for remain in range(INTERVAL, 0, -1):
                if not self.auto_running:
                    break
                if remain % 30 == 0 or remain <= 10:
                    self.write(f"[WARTEN] N√§chste Runde in {remain}s ...", "cyan")
                time.sleep(1)

        self.write("[INFO] Auto-Run beendet.", "yellow")

    # --- Runde: Mode 0 (Viele -> Ein) ---
    def _run_mode_ms(self):
        target_raw = self.ms_e_target.get().strip()
        treat_as_id = self.ms_var_target_is_id.get()
        if not target_raw:
            self.write("[FEHLER] Kein Empf√§nger gesetzt.", "red")
            return

        # Ziel-ID aufl√∂sen (einmalig)
        first_acc = self.ms_accounts[0]
        region = first_acc.get("country", "DE").upper()
        # WICHTIG: Tokenquelle setzen, damit find_profile_id darauf zugreift
        self.token_info = first_acc

        if treat_as_id or self._looks_like_uuid(target_raw) or "|" in target_raw:
            receiver_id = target_raw
            label = target_raw
        else:
            receiver_id = self.find_profile_id(target_raw, region)
            if not receiver_id:
                return
            label = f"{target_raw} ({receiver_id})"

        # Jeder Account sendet 1x
        for acc in list(self.ms_accounts):
            if not self.auto_running:
                break
            self.send_star_greeting(acc["access_token"], receiver_id, f"{label} ‚Üê {acc.get('username','?')}")
            time.sleep(1)

    # --- Runde: Mode 1 (Ein -> Viele) ---
    def _run_mode_sm(self):
        acc = self.sm_account
        region = acc.get("country", "DE").upper()
        # WICHTIG: Tokenquelle setzen
        self.token_info = acc

        entries = [self.sm_listbox.get(i) for i in range(self.sm_listbox.size())]
        treat_as_ids = self.sm_var_targets_are_ids.get()
        if not entries:
            self.write("[INFO] Keine Empf√§nger vorhanden.", "yellow")
            return

        for item in list(entries):
            if not self.auto_running:
                break

            if treat_as_ids or self._looks_like_uuid(item) or "|" in item:
                receiver_id = item
                label = item
            else:
                receiver_id = self.find_profile_id(item.strip(), region)
                if not receiver_id:
                    continue
                label = f"{item} ({receiver_id})"

            self.send_star_greeting(acc["access_token"], receiver_id, label)
            time.sleep(1)


class SpecialMassSenderTab(ttk.Frame):
    """
    Zwei Logins (jeweils doppelt), Ziel (Name oder profileId) eingeben,
    Greeting-Typ w√§hlen und 'N' parallele Anfragen *pro Account* abfeuern.
    Buttons: Threads vorbereiten -> gemeinsamer Start -> Stop.
    """
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.accounts = []            # Liste von token_info Dicts (je Login 2x)
        self.threads = []
        self.start_event = threading.Event()
        self.running = False
        self.token_info = None        # wird f√ºr find_profile_id verwendet (siehe Wunsch)
        self._build()

    # ---------- UI ----------
    def _build(self):
        pad = 6

        lf = ttk.LabelFrame(self, text="Logins einzeln (jeder wird doppelt eingeloggt)")
        lf.pack(fill="x", padx=pad, pady=pad)

        for i in range(2):
            ttk.Label(lf, text=f"Benutzer {i+1}").grid(row=i*4, column=0, sticky="w")
            setattr(self, f"e_user{i}", ttk.Entry(lf))
            getattr(self, f"e_user{i}").grid(row=i*4, column=1, padx=pad)

            ttk.Label(lf, text="Passwort").grid(row=i*4+1, column=0, sticky="w")
            setattr(self, f"e_pw{i}", ttk.Entry(lf, show="*"))
            getattr(self, f"e_pw{i}").grid(row=i*4+1, column=1, padx=pad)

            ttk.Label(lf, text="Land").grid(row=i*4+2, column=0, sticky="w")
            e_cty = ttk.Entry(lf); e_cty.insert(0, "DE")
            setattr(self, f"e_cty{i}", e_cty)
            e_cty.grid(row=i*4+2, column=1, padx=pad)

            ttk.Button(lf, text=f"Login Benutzer {i+1}",
                       command=lambda idx=i: self.login_click(idx)).grid(row=i*4+3, columnspan=2, pady=pad)

        tf = ttk.LabelFrame(self, text="üéØ Ziel & Einstellungen")
        tf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(tf, text="Ziel (Name oder profileId):").grid(row=0, column=0, sticky="w")
        self.e_target = ttk.Entry(tf); self.e_target.grid(row=0, column=1, sticky="ew", padx=pad)
        tf.columnconfigure(1, weight=1)

        self.var_is_id = tk.BooleanVar(value=False)
        ttk.Checkbutton(tf, text="Eingabe ist bereits profileId",
                        variable=self.var_is_id).grid(row=1, column=1, sticky="w", padx=pad, pady=(0, 4))

        ttk.Label(tf, text="Greeting-Typ:").grid(row=2, column=0, sticky="w")
        self.greeting_var = tk.StringVar(value="StarGreeting")
        ttk.Combobox(tf, textvariable=self.greeting_var,
                     values=["StarGreeting", "Autograph"],
                     state="readonly", width=18).grid(row=2, column=1, sticky="w", padx=pad, pady=(0, 4))

        ttk.Label(tf, text="Parallele Anfragen pro Account:").grid(row=3, column=0, sticky="w")
        self.per_acc_threads = tk.IntVar(value=1)
        ttk.Spinbox(tf, from_=1, to=200, textvariable=self.per_acc_threads, width=6)\
           .grid(row=3, column=1, sticky="w", padx=pad)

        ttk.Button(self, text="üß† Threads vorbereiten", command=self.prepare_threads).pack(pady=pad)
        ttk.Button(self, text="üéØ Jetzt starten", command=self.start_event.set).pack(pady=(0, pad))
        ttk.Button(self, text="‚èπÔ∏è Stop", command=self.stop).pack(pady=(0, pad))

        self.log = ScrolledText(self, height=12, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    # ---------- Login ----------
    def login_click(self, idx: int):
        u = getattr(self, f"e_user{idx}").get().strip()
        p = getattr(self, f"e_pw{idx}").get().strip()
        c = getattr(self, f"e_cty{idx}").get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")

        try:
            for i in range(2):  # doppelt einloggen (wie gew√ºnscht)
                token_info = login(u, p, c)
                token_info["username"] = u
                token_info["country"]  = c
                self.accounts.append(token_info)
                # ‚úÖ DEBUG-Ausgabe f√ºr Token-Vergleich
                self.write(f"[DEBUG] Token {len(self.accounts)}: {token_info['access_token'][:1000]}...", "cyan")
            self.write(f"[OK] Benutzer {idx+1} doppelt eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login Benutzer {idx+1}: {e}", "red")
            messagebox.showerror("Login", str(e))

    # ---------- Threads vorbereiten ----------
    def prepare_threads(self):
        if not self.accounts:
            return messagebox.showwarning("Fehler", "Bitte mindestens einen Benutzer einloggen.")

        target_raw = (self.e_target.get() or "").strip()
        if not target_raw:
            return messagebox.showwarning("Fehler", "Bitte Ziel eingeben.")

        # F√ºr die gew√ºnschte find_profile_id verwenden wir self.token_info (= erster Account)
        self.token_info = self.accounts[0]
        region = self.token_info.get("country", "DE").upper()

        if self.var_is_id.get() or self._looks_like_uuid(target_raw) or "|" in target_raw:
            receiver_id = target_raw
            label = target_raw
        else:
            receiver_id = self.find_profile_id(target_raw, region)  # *** exakt nach deiner Vorlage ***
            if not receiver_id:
                return
            label = f"{target_raw} ({receiver_id})"

        self.threads.clear()
        self.start_event.clear()
        self.running = True

        per_acc = max(1, int(self.per_acc_threads.get()))
        greeting_type = self.greeting_var.get()

        for acc in self.accounts:
            token = acc["access_token"]
            for _ in range(per_acc):
                t = threading.Thread(
                    target=self._worker_send_once,
                    args=(token, receiver_id, greeting_type, f"{label} ‚Üê {acc.get('username','?')}"),
                    daemon=True
                )
                self.threads.append(t)

        for t in self.threads:
            t.start()

        self.write(f"[INFO] {len(self.accounts)} Accounts √ó {per_acc} Threads vorbereitet "
                   f"(gesamt {len(self.threads)}). Klicke jetzt auf 'üéØ Jetzt starten'.", "cyan")

    def _worker_send_once(self, token, receiver_id, greeting_type, label):
        self.start_event.wait()   # Synchronstart
        if not self.running:
            return
        self._send_greeting_once(token, receiver_id, greeting_type, label)

    def stop(self):
        self.running = False
        self.start_event.set()
        self.write("[INFO] gestoppt.", "yellow")

    # ---------- Request ----------
    def _send_greeting_once(self, access_token, receiver_profile_id, greeting_type, label):
        try:
            url = "https://eu.mspapis.com/federationgateway/graphql"
            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json",
                "Referer": "https://moviestarplanet2.com/",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36"
            }
            payload = {
                "id": "SendGreetings-159BDD7706D824BB8F14874A7FAE3368",
                "variables": {
                    "greetingType": greeting_type,   # "StarGreeting" oder "Autograph"
                    "receiverProfileId": receiver_profile_id,
                    "ignoreDailyCap": False
                }
            }
            res = self.scraper.post(url, headers=headers, json=payload, timeout=8)
            res.raise_for_status()
            data = res.json()
            success = (
                data.get("data", {}).get("greetings", {}).get("sendGreeting", {}).get("success", False)
            ) or (
                data.get("data", {}).get("sendGreeting", {}).get("success", False)
            )
            if success:
                self.after(0, self.write, f"[OK] {greeting_type} ‚Üí {label}", "green")
            else:
                self.after(0, self.write, f"[FEHLER] {greeting_type} ‚Üí {label} fehlgeschlagen.", "red")
        except Exception as e:
            self.after(0, self.write, f"[FEHLER] {greeting_type} ‚Üí {label}: {e}", "red")

    # ---------- Utils ----------
    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

    def _looks_like_uuid(self, s: str) -> bool:
        s = (s or "").strip().lower()
        return len(s) == 32 and all(c in "0123456789abcdef" for c in s)

    # *** exakt DEINE gew√ºnschte find_profile_id ‚Äì unver√§ndert √ºbernommen ***
    def find_profile_id(self, username, region):
        try:
            url = "https://eu.mspapis.com/edgerelationships/graphql/graphql"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Content-Type": "application/json"
            }
            query = """
            query GetProfileSearch($region: String!, $startsWith: String!, $pageSize: Int, $currentPage: Int, $preferredGameId: String!) {
                findProfiles(region: $region, nameBeginsWith: $startsWith, pageSize: $pageSize, page: $currentPage) {
                    totalCount
                    nodes {
                        id
                        avatar(preferredGameId: $preferredGameId) {
                            gameId
                            face
                            full
                        }
                    }
                }
            }
            """
            variables = {
                "region": region,
                "startsWith": username,
                "pageSize": 50,
                "currentPage": 1,
                "preferredGameId": "j68d"
            }
            payload = {"query": query, "variables": variables}
            r = self.scraper.post(url, headers=headers, json=payload)
            r.raise_for_status()
            data = r.json()
            nodes = data.get("data", {}).get("findProfiles", {}).get("nodes", [])
            if not nodes:
                self.write(f"[FEHLER] Kein Profil mit dem Namen '{username}' gefunden.", "red")
                return None
            return nodes[0]["id"]
        except Exception as e:
            self.write(f"[FEHLER] Profil-ID konnte nicht ermittelt werden: {e}", "red")
            return None
        
# -------------------- Password Change Tab (Identity-Bearer direkt) --------------------
class PasswordChangeTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.token_info = None
        self.identity_access_token = None
        self.identity_claims = {}
        self.country = "DE"
        self.game_id = "j68d"
        self.display_name = ""
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf)
        self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*")
        self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf)
        self.e_cty.insert(0, "DE")
        self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        cf = ttk.LabelFrame(self, text="Passwort √§ndern")
        cf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(cf, text="Neues Passwort").grid(row=0, column=0, sticky="w")
        self.e_new_pw = ttk.Entry(cf, show="*")
        self.e_new_pw.grid(row=0, column=1, padx=pad)

        ttk.Button(self, text="üîë Einzel √§ndern", command=self.change_password_click).pack(pady=(0, pad))

        # Batch √Ñnderung mit Thread
        ttk.Button(self, text="üîÅ Massen√§nderung (pwr.txt)", 
                   command=lambda: threading.Thread(target=self.batch_change_passwords, daemon=True).start()
                   ).pack(pady=(0, pad))

        self.claim_text = tk.StringVar()
        ttk.Label(self, textvariable=self.claim_text, justify="left").pack(pady=(0, pad))

        self.log = ScrolledText(self, height=12, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

    def _jwt_payload(self, jwt_token: str) -> dict:
        try:
            parts = jwt_token.split(".")
            if len(parts) < 2:
                return {}
            import base64
            pad_len = (-len(parts[1]) % 4)
            payload = base64.urlsafe_b64decode(parts[1] + ("=" * pad_len))
            return json.loads(payload.decode("utf-8", errors="ignore"))
        except Exception:
            return {}

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")
        self.country = c
        try:
            acc = login(u, p, c)
            acc["username"] = u
            acc["password"] = p
            acc["country"] = c
            self.token_info = acc
            self.display_name = acc.get("username", u)
            self.write(f"[OK] Eingeloggt als {u}", "green")

            at = self.token_info.get("access_token", "")
            claims = self._jwt_payload(at)
            if at:
                self.identity_access_token = acc.get("access_token", "")
                self.identity_claims = self._jwt_payload(self.identity_access_token)
                self.write("[OK] Identity-Access-Token √ºbernommen.", "green")
                pretty = "\n".join([f"{k}: {v}" for k, v in self.identity_claims.items()])
                self.claim_text.set(f"üîê JWT Claims:\n{pretty}")
            else:
                self.write("[WARN] Identity-Token fehlte ‚Äì GraphQL wird fehlschlagen.", "yellow")
        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")
            messagebox.showerror("Login", str(e))

    def change_password_click(self):
        if not self.token_info:
            return messagebox.showwarning("Nicht eingeloggt", "Bitte zuerst einloggen.")
        if not self.identity_access_token:
            self.write("[FEHLER] Identity-Token fehlt ‚Äì Passwort √§ndern nicht m√∂glich.", "red")
            return

        new_pw = self.e_new_pw.get().strip()
        if not new_pw:
            return messagebox.showwarning("Fehler", "Neues Passwort eingeben.")

        login_id = self.identity_claims.get("loginId") or self.identity_claims.get("sub") or ""
        if not login_id:
            self.write("[FEHLER] Konnte loginId nicht aus Identity-Token lesen.", "red")
            return

        profile_id = self.token_info.get("profile_id", "")
        if not profile_id:
            self.write("[FEHLER] profile_id fehlt aus Game-Login.", "red")
            return

        name = self.display_name or self.token_info.get("username", "")

        try:
            ok = self._change_password_edgelogins(
                bearer=self.identity_access_token,
                login_id=login_id,
                profile_id=profile_id,
                game_id=self.game_id,
                name=name,
                current_password=self.token_info.get("password", ""),
                new_password=new_pw,
                is_guest=False
            )
            if ok:
                self.write("[OK] Passwort erfolgreich ge√§ndert.", "green")
            else:
                self.write("[FEHLER] Passwort √§ndern fehlgeschlagen (siehe Log).", "red")
        except Exception as e:
            self.write(f"[FEHLER] Passwort √§ndern: {e}", "red")

    def batch_change_passwords(self):
        try:
            with open("pwr.txt", "r", encoding="utf-8") as f:
                lines = [line.strip() for line in f if line.strip()]
        except Exception as e:
            return self.write(f"[FEHLER] Datei pwr.txt konnte nicht gelesen werden: {e}", "red")

        new_pw = self.e_new_pw.get().strip()
        if not new_pw:
            return self.write("[FEHLER] Neues Passwort ist leer.", "red")

        success, fail = 0, 0

        for line in lines:
            try:
                if ":" not in line:
                    self.write(f"[WARN] Ung√ºltiges Format (user:pass): {line}", "yellow")
                    fail += 1
                    continue
                user, pw = line.split(":", 1)
                acc = login(user, pw, self.country)
                acc["username"] = user
                acc["password"] = pw
                acc["country"] = self.country
                identity_access_token = acc.get("access_token", "")
                identity_claims = self._jwt_payload(identity_access_token)
                login_id = identity_claims.get("loginId") or identity_claims.get("sub")
                profile_id = acc.get("profile_id", "")

                ok = self._change_password_edgelogins(
                    bearer=identity_access_token,
                    login_id=login_id,
                    profile_id=profile_id,
                    game_id=self.game_id,
                    name=user,
                    current_password=pw,
                    new_password=new_pw,
                    is_guest=False
                )
                if ok:
                    self.write(f"[OK] Passwort ge√§ndert f√ºr {user}", "green")
                    success += 1
                else:
                    self.write(f"[FEHLER] Passwort√§nderung fehlgeschlagen f√ºr {user}", "red")
                    fail += 1
            except Exception as e:
                self.write(f"[FEHLER] {user}: {e}", "red")
                fail += 1

        self.write(f"\n[INFO] Fertig. Erfolgreich: {success} / Fehler: {fail}\n", "cyan")

    def _change_password_edgelogins(self, bearer: str, login_id: str, profile_id: str,
                                    game_id: str, name: str,
                                    current_password: str, new_password: str,
                                    is_guest: bool = False) -> bool:
        url = "https://edgelogins.eu.moviestarplanet.app/graphql"
        headers = {
            "Authorization": f"Bearer {bearer}",
            "Content-Type": "application/json",
            "Referer": "https://moviestarplanet2.com/",
            "User-Agent": "Mozilla/5.0"
        }

        query = (
            "mutation UpdateLogin($loginId: String!, $profileId: String!, $gameId: String!, $name: String, "
            "$currentPassword: String!, $newPassword: String!, $isGuest: Boolean){"
            "updateLoginProfile(input: { loginId: $loginId, profileId: $profileId, gameId: $gameId, name: $name, "
            "passwords: { currentPassword: $currentPassword, newPassword: $newPassword}, isGuest: $isGuest}) "
            "{success,loginProfile {loginId,loginName,profileId,profileName,isGuest},error}}"
        )

        variables = {
            "loginId": login_id,
            "profileId": profile_id,
            "gameId": game_id,
            "name": name,
            "currentPassword": current_password,
            "newPassword": new_password,
            "isGuest": bool(is_guest),
        }

        payload = {"query": query, "variables": variables}

        try:
            r = self.scraper.post(url, headers=headers, json=payload, timeout=20)
            r.raise_for_status()
            js = r.json()
            data = js.get("data", {}).get("updateLoginProfile", {})
            if data.get("success") is True:
                return True
            return False
        except Exception:
            return False
        

# -------------------- Double Gift Sender --------------------
class GiftDoubleSenderTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.sender = None
        self.receivers = []
        self.start_event = threading.Event()
        self._build()

    def _build(self):
        pad = 6

        # Sender login
        lf_sender = ttk.LabelFrame(self, text="üéÅ Absender-Account")
        lf_sender.pack(fill="x", padx=pad, pady=pad)

        self.e_sender_user = ttk.Entry(lf_sender)
        self.e_sender_pw = ttk.Entry(lf_sender, show="*")
        self.e_sender_cty = ttk.Entry(lf_sender); self.e_sender_cty.insert(0, "DE")

        ttk.Label(lf_sender, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_sender_user.grid(row=0, column=1, padx=pad)
        ttk.Label(lf_sender, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_sender_pw.grid(row=1, column=1, padx=pad)
        ttk.Label(lf_sender, text="Land").grid(row=2, column=0, sticky="w")
        self.e_sender_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf_sender, text="Login Absender", command=self.login_sender).grid(row=3, columnspan=2, pady=pad)

        # Receiver logins
        lf_recv = ttk.LabelFrame(self, text="üéØ Empf√§nger-Accounts (2x)")
        lf_recv.pack(fill="x", padx=pad, pady=pad)
        self.receiver_entries = []

        for i in range(2):
            u = ttk.Entry(lf_recv)
            p = ttk.Entry(lf_recv, show="*")
            c = ttk.Entry(lf_recv); c.insert(0, "DE")
            ttk.Label(lf_recv, text=f"Benutzer {i+1}").grid(row=i*3, column=0, sticky="w")
            u.grid(row=i*3, column=1, padx=pad)
            ttk.Label(lf_recv, text="Passwort").grid(row=i*3+1, column=0, sticky="w")
            p.grid(row=i*3+1, column=1, padx=pad)
            ttk.Label(lf_recv, text="Land").grid(row=i*3+2, column=0, sticky="w")
            c.grid(row=i*3+2, column=1, padx=pad)
            self.receiver_entries.append((u, p, c))

        ttk.Button(lf_recv, text="Login Empf√§nger", command=self.login_receivers).grid(row=6, columnspan=2, pady=pad)

        # Gift Details
        gf = ttk.LabelFrame(self, text="üéÅ Geschenk senden")
        gf.pack(fill="x", padx=pad, pady=pad)
        ttk.Label(gf, text="üéÅ InventoryItemId").grid(row=0, column=0)
        self.e_itemid = ttk.Entry(gf)
        self.e_itemid.grid(row=0, column=1, padx=pad)
        ttk.Button(gf, text="üöÄ Jetzt senden & √∂ffnen", command=self.send_and_open).grid(row=3, columnspan=2, pady=pad)

        # Log
        self.log = tk.Text(self, height=12, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def write(self, msg, col=None):
        self.log.insert(tk.END, msg + "\n")
        self.log.see(tk.END)

    def login_sender(self):
        u = self.e_sender_user.get().strip()
        p = self.e_sender_pw.get().strip()
        c = self.e_sender_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Absenderdaten ausf√ºllen.")
        try:
            acc = login(u, p, c)
            acc["country"] = c
            acc["username"] = u
            self.sender = acc
            self.write(f"[OK] Absender eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Absender-Login: {e}", "red")

    def login_receivers(self):
        self.receivers.clear()
        for i, (u_entry, p_entry, c_entry) in enumerate(self.receiver_entries):
            u = u_entry.get().strip()
            p = p_entry.get().strip()
            c = c_entry.get().strip().upper()
            if not all([u, p, c]):
                return messagebox.showwarning("Fehler", f"Empf√§nger {i+1} unvollst√§ndig.")
            try:
                acc = login(u, p, c)
                acc["username"] = u
                acc["country"] = c
                self.receivers.append(acc)
                self.write(f"[OK] Empf√§nger {i+1} eingeloggt: {u}", "green")
            except Exception as e:
                self.write(f"[FEHLER] Empf√§nger {i+1}: {e}", "red")

    def send_and_open(self):
        if not self.sender or len(self.receivers) < 2:
            return messagebox.showwarning("Fehler", "Absender und 2 Empf√§nger m√ºssen eingeloggt sein.")
        item_id = self.e_itemid.get().strip()
        if not item_id:
            return messagebox.showwarning("Fehler", "Bitte Item ID eingeben.")

        self.write("[INFO] Sende Geschenke gleichzeitig...", "yellow")

        # Geschenke gleichzeitig senden
        threads = []
        for recv in self.receivers:
            t = threading.Thread(target=self._give_gift, args=(self.sender, recv, item_id), daemon=True)
            threads.append(t)
            t.start()

        def proceed_after_send():
            self.write("[INFO] Geschenke gesendet. Sammle giftIds...", "yellow")
            gift_ids = []
            for r in self.receivers:
                gid = self._fetch_latest_gift(r)
                if gid:
                    gift_ids.append((r, gid))

            if len(gift_ids) < 2:
                self.write("[FEHLER] Konnte nicht beide Geschenke finden.", "red")
                return

            self.write(f"[OK] Geschenke gefunden. √ñffne jetzt 5x pro Empf√§nger (synchron)...", "green")

            # 10 Threads (5 pro Account), warten bis alle bereit, dann exakt gleichzeitig starten
            barrier = threading.Barrier(parties=10)

            for acc, gid in gift_ids:
                for _ in range(5):
                    t = threading.Thread(
                        target=self._open_gift_barrier,
                        args=(acc, gid, barrier),
                        daemon=True
                    )
                    t.start()

        self.after(1500, proceed_after_send)

    def _open_gift_barrier(self, acc, gift_id, barrier):
        try:
            barrier.wait()  # Warte auf alle Threads
        except threading.BrokenBarrierError:
            self.after(0, self.write, f"[FEHLER] Barrier unterbrochen f√ºr {acc['username']}", "red")
            return

        payload = {
            "query": """
            mutation OpenGift($giftId: ID!, $receiverProfileId: ID!) {
                openGift(input: {
                    giftId: $giftId,
                    receiverProfileId: $receiverProfileId
                }) {
                    success
                    error
                    item { id }
                }
            }
            """,
            "variables": {
                "giftId": gift_id,
                "receiverProfileId": acc["profile_id"]
            }
        }
        headers = {
            "Authorization": f"Bearer {acc['access_token']}",
            "Content-Type": "application/json",
        }
        try:
            res = self.scraper.post("https://eu.mspapis.com/edgegifts/graphql/graphql", headers=headers, json=payload)
            js = res.json()
            data = js.get("data", {}).get("openGift", {})
            if data.get("success"):
                item_id = data["item"]["id"]
                self.after(0, self.write, f"[OK] Geschenk ge√∂ffnet ({acc['username']}) Item: {item_id}", "green")
            else:
                err = data.get("error", "Unbekannter Fehler")
                self.after(0, self.write, f"[FEHLER] √ñffnen ({acc['username']}): {err}", "red")
        except Exception as e:
            self.after(0, self.write, f"[FEHLER] √ñffnen ({acc['username']}): {e}", "red")

    def _give_gift(self, sender, receiver, item_id):
        payload = {
            "query": """
            mutation GiveGifts($giverProfileId: ID!, $receiverProfileId: ID!, $inventoryItemId: ID!, $gameId: String!, $message: String, $additionalData: String) {
                giveGift(input: {
                    giverProfileId: $giverProfileId
                    receiverProfileId: $receiverProfileId
                    inventoryItemId: $inventoryItemId
                    gameId: $gameId
                    message: $message
                    additionalData: $additionalData
                }) {
                    success
                    error
                    gift { giftId }
                }
            }
            """,
            "variables": {
                "giverProfileId": sender["profile_id"],
                "receiverProfileId": receiver["profile_id"],
                "inventoryItemId": item_id,
                "gameId": "j68d",
                "message": "",
                "additionalData": ""
            }
        }
        headers = {
            "Authorization": f"Bearer {sender['access_token']}",
            "Content-Type": "application/json",
            "Referer": "https://moviestarplanet2.com/",
        }
        try:
            res = self.scraper.post("https://eu.mspapis.com/edgegifts/graphql/graphql", headers=headers, json=payload)
            js = res.json()
            if js.get("data", {}).get("giveGift", {}).get("success"):
                self.write(f"[OK] Geschenk an {receiver['username']} gesendet.", "green")
            else:
                err = js.get("data", {}).get("giveGift", {}).get("error", "Unbekannter Fehler")
                self.write(f"[FEHLER] Senden an {receiver['username']}: {err}", "red")
        except Exception as e:
            self.write(f"[FEHLER] Geschenk senden: {e}", "red")

    def _fetch_latest_gift(self, acc):
        self.write(f"[INFO] Pr√ºfe Geschenke f√ºr {acc['username']}", "blue")
        payload = {
            "query": """
            query CheckGifts($profileId: ID!, $gameId: String!, $pageSize: Int, $cursor: String) {
                gifts(input: {profileId: $profileId, gameId: $gameId, pageSize: $pageSize, cursor: $cursor }) {
                    gifts { giftId }
                }
            }
            """,
            "variables": {
                "profileId": acc["profile_id"],
                "gameId": "j68d",
                "pageSize": 12,
                "cursor": None
            }
        }
        headers = {
            "Authorization": f"Bearer {acc['access_token']}",
            "Content-Type": "application/json",
        }
        try:
            res = self.scraper.post("https://eu.mspapis.com/edgegifts/graphql/graphql", headers=headers, json=payload)
            res.raise_for_status()
            data = res.json().get("data", {}).get("gifts", {}).get("gifts", [])
            if data:
                gift_id = data[0]["giftId"]
                self.write(f"[OK] Geschenk gefunden f√ºr {acc['username']}: {gift_id}", "green")
                return gift_id
            else:
                self.write(f"[WARN] Keine Geschenke gefunden f√ºr {acc['username']}", "yellow")
        except Exception as e:
            self.write(f"[FEHLER] Geschenk abrufen ({acc['username']}): {e}", "red")
        return ""

    def _open_gift(self, acc, gift_id):
        self.start_event.wait()
        payload = {
            "query": """
            mutation OpenGift($giftId: ID!, $receiverProfileId: ID!) {
                openGift(input: {
                    giftId: $giftId,
                    receiverProfileId: $receiverProfileId
                }) {
                    success
                    error
                    item { id }
                }
            }
            """,
            "variables": {
                "giftId": gift_id,
                "receiverProfileId": acc["profile_id"]
            }
        }
        headers = {
            "Authorization": f"Bearer {acc['access_token']}",
            "Content-Type": "application/json",
        }
        try:
            res = self.scraper.post("https://eu.mspapis.com/edgegifts/graphql/graphql", headers=headers, json=payload)
            res.raise_for_status()
            js = res.json()
            data = js.get("data", {}).get("openGift", {})
            if data.get("success"):
                item_id = data["item"]["id"]
                self.after(0, self.write, f"[OK] Geschenk ge√∂ffnet ({acc['username']}) Item: {item_id}", "green")
            else:
                err = data.get("error", "Unbekannter Fehler")
                self.after(0, self.write, f"[FEHLER] √ñffnen ({acc['username']}): {err}", "red")
        except Exception as e:
            self.after(0, self.write, f"[FEHLER] √ñffnen ({acc['username']}): {e}", "red")


# -------------------- Monster --------------------
class MonsterTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.token_info = None
        self.scrapers = {}
        self._build()

    def _build(self):
        pad = 6

        lf = ttk.LabelFrame(self, text="Login")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf)
        self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*")
        self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf)
        self.e_cty.insert(0, "DE")
        self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        self.e_reward = ttk.Entry(self)
        self.e_reward.insert(0, "Item ID zum claimen")
        self.e_reward.pack(padx=pad, pady=(0, 5), fill="x")

        ttk.Button(self, text="ü•• Claim", command=self.start_claiming).pack(pady=pad)

        self.combo_claim = ttk.Combobox(self, values=["1", "2", "3", "4", "5", "6", "7"], state="readonly", width=5)
        self.combo_claim.set("1")
        self.combo_claim.pack(pady=(0, 2))
        ttk.Button(self, text="üìú Mehrere Claim", command=self.list_claim).pack(pady=(0, pad))

        ttk.Button(self, text="ü•≠ ItemClaim", command=self.start_item_claim).pack(pady=pad)

        self.combo_item = ttk.Combobox(self, values=["1", "2", "3", "4", "5", "6", "7"], state="readonly", width=5)
        self.combo_item.set("1")
        self.combo_item.pack(pady=(0, 2))
        ttk.Button(self, text="üìú Mehrere ItemClaim", command=self.list_item_claim).pack(pady=(0, pad))

        self.log = tk.Text(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def get_scraper(self, username):
        return self.scrapers.get(username) or cloudscraper.create_scraper()

    def load_proxies(self):
        proxies = []
        try:
            with open("proxies.txt", "r", encoding="utf-8") as f:
                for line in f:
                    if "@" in line:
                        userpass, host, port = line.strip().split("@")
                        user, pwd = userpass.split(":")
                        proxy_url = f"http://{user}:{pwd}@{host}:{port}"
                        proxies.append({"http": proxy_url, "https": proxy_url})
        except:
            pass
        return proxies

    def assign_scraper(self, username):
        proxy_list = self.load_proxies()
        scraper = cloudscraper.create_scraper()
        if proxy_list:
            proxy = random.choice(proxy_list)
            scraper.proxies = proxy
        self.scrapers[username] = scraper

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")
        try:
            self.assign_scraper(u)
            self.token_info = login(u, p, c, proxies=self.get_scraper(u).proxies)
            self.token_info["username"] = u
            self.write(f"[OK] Eingeloggt als {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def start_claiming(self):
        if not self.token_info:
            return messagebox.showwarning("Fehler", "Bitte zuerst einloggen!")
        threading.Thread(target=self.claim_rewards, args=(self.token_info,), daemon=True).start()

    def start_item_claim(self):
        if not self.token_info:
            return messagebox.showwarning("Fehler", "Bitte zuerst einloggen!")
        threading.Thread(target=self.claim_item_reward, args=(self.token_info,), daemon=True).start()

    def list_claim(self):
        def worker():
            file_id = self.combo_claim.get()
            suffix = '' if file_id == '1' else file_id
            dateiname = f"acclist{suffix}.txt"
            try:
                with open(dateiname, "r", encoding="utf-8") as f:
                    for line in f:
                        parts = line.strip().split(":")
                        if len(parts) < 2: continue
                        u, p = parts[0], parts[1]
                        c = parts[2] if len(parts) >= 3 else "DE"
                        try:
                            self.assign_scraper(u)
                            token_info = login(u, p, c, proxies=self.get_scraper(u).proxies)
                            token_info["username"] = u
                            self.write(f"[Login] {u}", "green")
                            self.claim_rewards(token_info)
                        except Exception as e:
                            self.write(f"[FEHLER] {u}: {e}", "red")
                        time.sleep(0.5)
            except Exception as e:
                self.write(f"[FEHLER] Datei: {e}", "red")
        threading.Thread(target=worker, daemon=True).start()

    def list_item_claim(self):
        def worker():
            file_id = self.combo_item.get()
            suffix = '' if file_id == '1' else file_id
            dateiname = f"acclist{suffix}.txt"
            try:
                with open(dateiname, "r", encoding="utf-8") as f:
                    for line in f:
                        parts = line.strip().split(":")
                        if len(parts) < 2: continue
                        u, p = parts[0], parts[1]
                        c = parts[2] if len(parts) >= 3 else "DE"
                        try:
                            self.assign_scraper(u)
                            token_info = login(u, p, c, proxies=self.get_scraper(u).proxies)
                            token_info["username"] = u
                            self.write(f"[Login] {u}", "cyan")
                            self.claim_item_reward(token_info)
                        except Exception as e:
                            self.write(f"[FEHLER] {u}: {e}", "red")
                        time.sleep(0.5)
            except Exception as e:
                self.write(f"[FEHLER] Datei: {e}", "red")
        threading.Thread(target=worker, daemon=True).start()

    def claim_rewards(self, token_info):
        token = token_info['access_token']
        profile_id = token_info['profile_id']
        username = token_info.get("username", "Unbekannt")
        scraper = self.get_scraper(username)
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
            "Referer": "https://moviestarplanet2.com/",
            "User-Agent": "Mozilla/5.0"
        }
        payload = {"state": "Claimed"}
        actions = [
            ("halloween_25_plaza_monster", 6),
            #("summer_25_coconut_tree_03", 3),
            ("halloween_25_diamond_shop_monster", 4),
            ("halloween_25_forest_monster", 3),
            ("halloween_25_spider_minigame_forest", 3),
            ("halloween_25_spider_minigame", 3),
            ("halloween_25_spider_minigame_plaza", 3),
            ("halloween_25_beach_monster", 5),
            ("halloween_25_event_chatroom_monster", 3),
            ("halloween_25_spider_minigame_tokio", 3),
            #("summer_25_coconut_tree_05", 3),
            #("summer_25_party_night_coconut", 2),
            #("summer_25_party_day_coconut", 4),
            #("summer_25_under_water_coconut", 2),
            ("halloween_25_vip_club_monster", 2)
        ]
        for reward_id, count in actions:
            url = f"https://eu.mspapis.com/timelimitedrewards/v2/profiles/{profile_id}/games/j68d/rewards/{reward_id}"
            for _ in range(count):
                try:
                    res = scraper.put(url, headers=headers, json=payload, timeout=10)
                    if res.status_code == 200:
                        self.write(f"[OK] {username}: {reward_id}", "green")
                    else:
                        self.write(f"[FEHLER] {username}: {reward_id}: {res.status_code}", "red")
                except Exception as e:
                    self.write(f"[FEHLER] {username}: {reward_id}: {e}", "red")
                time.sleep(0.01)

    def claim_item_reward(self, token_info):
        token = token_info['access_token']
        profile_id = token_info['profile_id']
        username = token_info.get("username", "Unbekannt")
        reward_id = self.e_reward.get().strip()
        scraper = self.get_scraper(username)
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
            "Referer": "https://moviestarplanet2.com/",
            "User-Agent": "Mozilla/5.0"
        }
        payload = {"state": "Claimed"}
        url = f"https://eu.mspapis.com/timelimitedrewards/v2/profiles/{profile_id}/games/j68d/rewards/{reward_id}"
        try:
            res = scraper.put(url, headers=headers, json=payload, timeout=10)
            if res.status_code == 200:
                self.write(f"[OK] {username}: {reward_id}", "green")
            else:
                self.write(f"[FEHLER] {username}: {reward_id}: {res.status_code}", "red")
        except Exception as e:
            self.write(f"[FEHLER] {username}: {reward_id}: {e}", "red")

    def write(self, msg, col=None):
        self.log.insert(tk.END, msg + "\n")
        self.log.see(tk.END)


# -------------------- MoodTab --------------------
class MoodTab(ttk.Frame):
    MOODS = {
        "Ice Skating": "noshoes_skating",
        "Swimming": "swim_new",
        "Bunny": "bunny_hold",
        "Spider Crawl": "2023_spidercrawl_lsz",
        "My World": "bad_2022_teenwalk_dg",
        "Frosty": "xmas_2022_frosty_dg",
        "Freezing": "xmas_2022_freezing_lsz",
        "Like a Turkey": "2022_turkeywalk_lsz",
        "Sacking Behind": "2022_easter_sackjump_dg",
        "Cool Slide": "cool_slide",
        "Like a Frog": "very_2022_froglike_lsz"
    }

    def __init__(self, master):
        super().__init__(master)
        self.token_info = None
        self.scraper = cloudscraper.create_scraper()
        self.attributes = {}
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf)
        self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*")
        self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf)
        self.e_cty.insert(0, "DE")
        self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        mood_frame = ttk.LabelFrame(self, text="Mood √§ndern")
        mood_frame.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(mood_frame, text="üé≠ Mood w√§hlen").grid(row=0, column=0, sticky="w")
        self.mood_dropdown = ttk.Combobox(
            mood_frame, state="readonly", values=list(self.MOODS.keys())
        )
        self.mood_dropdown.set("Ice Skating")
        self.mood_dropdown.grid(row=0, column=1, padx=pad, sticky="ew")
        mood_frame.columnconfigure(1, weight=1)

        ttk.Button(self, text="üéØ Mood √§ndern", command=self.change_mood).pack(pady=pad)

        self.log = ScrolledText(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")

        try:
            self.token_info = login(u, p, c)
            self.token_info["username"] = u
            self.write(f"[OK] Eingeloggt als {u}", "green")
            self.load_attributes()
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def load_attributes(self):
        profile_id = self.token_info["profile_id"]
        token = self.token_info["access_token"]
        url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{profile_id}/games/j68d/attributes"
        headers = {
            "Authorization": f"Bearer {token}",
            "Accept": "application/json"
        }
        try:
            r = self.scraper.get(url, headers=headers)
            r.raise_for_status()
            data = r.json()
            self.attributes = data.get("additionalData", {})
            self.write("[INFO] Daten erfolgreich geladen.", "cyan")
        except Exception as e:
            self.write(f"[FEHLER] Daten konnten nicht geladen werden: {e}", "red")

    def change_mood(self):
        if not self.token_info or not self.attributes:
            return messagebox.showwarning("Fehler", "Bitte zuerst einloggen und Daten laden.")

        mood_name = self.mood_dropdown.get()
        mood_code = self.MOODS[mood_name]  # z. B. "noshoes_skating"

        try:
            profile_id = self.token_info["profile_id"]
            token = self.token_info["access_token"]
            url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{profile_id}/games/j68d/attributes"
            headers = {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            }

            # Lade aktuelle Attribute
            payload = {
                "additionalData": dict(self.attributes)
            }

            # Mood direkt im Root-Level von additionalData setzen
            payload["additionalData"]["Mood"] = mood_code

            res = self.scraper.put(url, headers=headers, json=payload)

            if res.status_code == 200:
                self.write(f"[OK] Mood ge√§ndert zu: {mood_code}", "green")
            else:
                self.write(f"[FEHLER] √Ñnderung fehlgeschlagen: {res.status_code} - {res.text}", "red")

        except Exception as e:
            self.write(f"[FEHLER] Mood-√Ñnderung fehlgeschlagen: {e}", "red")

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_configure(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)


# -------------------- EventClaim --------------------
class EventClaimQuestTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.scrapers = {}
        self.accounts = []
        self._build()

    def _build(self):
        pad = 6

        lf = ttk.LabelFrame(self, text="Login manuell")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf)
        self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*")
        self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf)
        self.e_cty.insert(0, "DE")
        self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        ttk.Label(self, text="üìÑ Liste ausw√§hlen").pack()
        self.combo_claim = ttk.Combobox(self, values=["1", "2", "3", "4", "5", "6", "7"], state="readonly", width=5)
        self.combo_claim.set("1")
        self.combo_claim.pack(pady=(0, 2))
        ttk.Button(self, text="üìú Liste einloggen", command=self.login_from_file).pack(pady=(0, pad))

        ttk.Button(self, text="üå¥ Summer Quests starten", command=self.start_quests).pack(pady=pad)

        self.log = tk.Text(self, height=12, bg="#000000", fg="white", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")
        try:
            scraper = cloudscraper.create_scraper()
            token_info = login(u, p, c, proxies=scraper.proxies)
            token_info["username"] = u
            self.scrapers[u] = scraper
            self.accounts.append(token_info)
            self.write(f"[Login] {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login fehlgeschlagen", str(e))

    def login_from_file(self):
        file_id = self.combo_claim.get()
        suffix = '' if file_id == '1' else file_id
        dateiname = f"kokosnuss{suffix}.txt"

        def worker():
            try:
                with open(dateiname, "r", encoding="utf-8") as f:
                    for line in f:
                        parts = line.strip().split(":")
                        if len(parts) < 2:
                            continue
                        u, p = parts[0], parts[1]
                        c = parts[2] if len(parts) >= 3 else "DE"
                        try:
                            scraper = cloudscraper.create_scraper()
                            token_info = login(u, p, c, proxies=scraper.proxies)
                            token_info["username"] = u
                            self.scrapers[u] = scraper
                            self.write(f"[Login] {u}", "green")
                            self.complete_all_quests(token_info)  # Quests direkt nach Login
                        except Exception as e:
                            self.write(f"[FEHLER] {u}: {e}", "red")
                        time.sleep(2)
            except Exception as e:
                self.write(f"[FEHLER] Datei: {e}", "red")

        threading.Thread(target=worker, daemon=True).start()

    def start_quests(self):
        for acc in self.accounts:
            threading.Thread(target=self.complete_all_quests, args=(acc,), daemon=True).start()

    def complete_all_quests(self, acc):
        quest_ids = [
            "halloween_25_monster_hunt_1", "halloween_25_monster_hunt_2", "halloween_25_monster_hunt_3",
            "halloween_25_monster_hunt_4", "halloween_25_monster_hunt_5", "halloween_25_monster_hunt_6",
            "halloween_25_monster_hunt_7", "halloween_25_monster_hunt_8", "halloween_25_monster_hunt_9",
            "halloween_25_monster_hunt_10", "halloween_25_monster_hunt_11", "halloween_25_monster_hunt_12",
            "halloween_25_monster_hunt_13", "halloween_25_monster_hunt_14", "halloween_25_monster_hunt_15",
            "halloween_25_monster_hunt_16", "halloween_25_monster_hunt_17", "halloween_25_monster_hunt_18",
        ]

        headers = {
            "Authorization": f"Bearer {acc['access_token']}",
            "Content-Type": "application/json",
            "Referer": "https://moviestarplanet2.com/",
            "User-Agent": "Mozilla/5.0"
        }
        payload = {"state": "Complete"}
        profile_id = acc["profile_id"]
        username = acc["username"]
        scraper = self.scrapers[username]

        for qid in reversed(quest_ids):
            url = f"https://eu.mspapis.com/quests/v2/profiles/{profile_id}/games/j68d/quests/{qid}/state"
            try:
                res = scraper.put(url, headers=headers, json=payload, timeout=10)
                if res.status_code == 200:
                    self.write(f"[OK] {username}: {qid}", "green")
                else:
                    self.write(f"[FEHLER] {username}: {qid}: {res.status_code}", "red")
            except Exception as e:
                self.write(f"[FEHLER] {username}: {qid}: {e}", "red")
            time.sleep(0.2)

    def write(self, msg, col=None):
        self.log.insert(tk.END, msg + "\n")
        self.log.see(tk.END)




class MultiGreetingTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.accounts = []
        self.threads = []
        self.start_event = threading.Event()
        self._build()

    def _build(self):
        pad = 6

        lf = ttk.LabelFrame(self, text="Login (1 Account ‚Üí an mehrere Profile senden)")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername:").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort:").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land:").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0, "DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="üîë Login", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        gf = ttk.LabelFrame(self, text="üéØ Ziel-Profile")
        gf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(gf, text="Empf√§nger profileIds (Kommagetrennt oder Zeilenweise):").grid(row=0, column=0, sticky="w")
        self.e_targets = tk.Text(gf, height=3, width=40)
        self.e_targets.grid(row=1, column=0, columnspan=2, padx=pad, pady=(0,5))

        ttk.Button(self, text="üß† Threads vorbereiten", command=self.prepare_threads).pack(pady=pad)
        ttk.Button(self, text="üöÄ Jetzt starten", command=self.start_event.set).pack(pady=pad)

        self.log = tk.Text(self, height=10, bg="#000", fg="#0f0", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Bitte alle Felder ausf√ºllen!")

        try:
            token_info = login(u, p, c)
            token_info["username"] = u
            token_info["country"] = c
            self.accounts = [token_info]
            self.write(f"[OK] Eingeloggt als {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")
            messagebox.showerror("Login", str(e))

    def prepare_threads(self):
        if not self.accounts:
            return messagebox.showwarning("Fehler", "Bitte zuerst einloggen!")

        targets_raw = self.e_targets.get("1.0", tk.END).strip()
        if not targets_raw:
            return messagebox.showwarning("Fehler", "Bitte Empf√§nger-IDs angeben.")

        targets = [t.strip() for t in targets_raw.replace("\n", ",").split(",") if t.strip()]
        if not targets:
            return messagebox.showwarning("Fehler", "Keine g√ºltigen IDs gefunden.")

        self.threads.clear()
        self.start_event.clear()

        acc = self.accounts[0]

        for receiver_id in targets:
            t = threading.Thread(target=self.send_greeting, args=(acc, receiver_id), daemon=True)
            self.threads.append(t)

        for t in self.threads:
            t.start()

        self.write(f"[INFO] {len(self.threads)} Threads vorbereitet. Warte auf Startsignal...", "yellow")

    def send_greeting(self, acc, receiver_id):
        self.start_event.wait()  # Synchronstart

        token = acc["access_token"]
        session_id = str(uuid.uuid4())
        device_id = uuid.uuid4().hex.upper()
        ua = random.choice([
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
            "Mozilla/5.0 (Linux; Android 12; SM-A127F)",
            "Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X)"
        ])

        headers = {
            "authorization": f"Bearer {token}",
            "content-type": "application/json",
            "User-Agent": ua,
            "Referer": f"https://moviestarplanet2.com/?v={random.randint(1000,9999)}",
            "sessionId": session_id,
            "userDeviceId": device_id
        }

        payload = {
            "id": "SendGreetings-159BDD7706D824BB8F14874A7FAE3368",  # bleibt gleich
            "variables": {
                "greetingType": "Autograph",  # bleibt gleich
                "receiverProfileId": receiver_id,
                "ignoreDailyCap": False
            }
        }

        try:
            res = self.scraper.post("https://eu.mspapis.com/federationgateway/graphql",
                                    headers=headers, json=payload, timeout=8)
            res.raise_for_status()
            data = res.json()
            success = data.get("data", {}).get("sendGreeting", {}).get("success", False)
            if success:
                self.after(0, self.write, f"‚úÖ Erfolgreich an {receiver_id} gesendet", "green")
            else:
                self.after(0, self.write, f"‚ùå Blockiert / Antwort: {data}", "red")
        except Exception as e:
            self.after(0, self.write, f"[!] Fehler bei Empf√§nger {receiver_id}: {e}", "red")

    def write(self, msg, color=None):
        self.log.insert(tk.END, msg + "\n")
        self.log.see(tk.END)


class PetColorRedeemTab(ttk.Frame):
    """
    Tool zum Einl√∂sen eines Tier-Items mit einer einzelnen Farbe.
    - profile_id kommt aus token_info['profile_id'] nach login()
    - GUID muss im Feld angegeben werden
    - Farbe als Hex (z. B. #FEFFFEFF oder #9D0001FF25) angeben
    Hinweis: Dieses Tool macht eine legitime Claim-Anfrage an deinen lokalen Server/API.
    """

    def __init__(self, master):
        super().__init__(master)
        self.token_info = None
        self.scraper = cloudscraper.create_scraper()
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0,"DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        # Claim-Bereich
        cf = ttk.LabelFrame(self, text="Tier einl√∂sen (eine Farbe)")
        cf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(cf, text="ProfileId (wird aus Login verwendet)").grid(row=0, column=0, sticky="w", padx=pad, pady=(4,0))
        self.profile_label = ttk.Label(cf, text="(nicht eingeloggt)")
        self.profile_label.grid(row=0, column=1, sticky="w", padx=pad, pady=(4,0))

        ttk.Label(cf, text="GUID (Item) :").grid(row=1, column=0, sticky="w", padx=pad, pady=(6,0))
        self.e_guid = ttk.Entry(cf, width=48)
        self.e_guid.grid(row=1, column=1, padx=pad, pady=(6,0))

        ttk.Label(cf, text="Farbe zum Beispiel #000000:").grid(row=2, column=0, sticky="w", padx=pad, pady=(6,0))
        self.e_color = ttk.Entry(cf, width=48)
        self.e_color.grid(row=2, column=1, padx=pad, pady=(6,0))

        ttk.Button(cf, text="Einl√∂sen", command=self.claim_click).grid(row=3, columnspan=2, pady=pad) 

        # Optionen / Hinweis
        ttk.Label(self, text="Hinweis: Nur eine Farbe und mit Hashtag eingeben!", foreground="orange").pack(fill="x", padx=pad)

        # Log
        self.log = ScrolledText(self, height=12, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")

        try:
            self.token_info = login(u, p, c)  # erwartet access_token + profile_id
            pid = self.token_info.get("profile_id") or self.token_info.get("profileId") or "(unknown)"
            self.profile_label.config(text=str(pid))
            self.write(f"[OK] Eingeloggt als {u} (profile_id: {pid})", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")
            messagebox.showerror("Login", str(e))

    def _normalize_color(self, color_str):
        """
        Normiert und validiert Hex-Farben.
        Akzeptiert: '#' gefolgt von 3 bis 12 hex-Zeichen (also #RGB, #RRGGBB, #RRGGBBAA, oder l√§ngere Formen wie #9D0001FF25).
        Gibt den String in Gro√übuchstaben zur√ºck oder None bei ung√ºltigem Format.
        """
        if not color_str:
            return None
        c = color_str.strip()
        if not c.startswith("#"):
            c = "#" + c
        # Regex: # + 3..12 hex chars
        if re.fullmatch(r"#[A-Fa-f0-9]{3,12}", c):
            return c.upper()
        return None

    def claim_click(self):
        if not self.token_info:
            return messagebox.showwarning("Nicht eingeloggt", "Bitte zuerst einloggen.")

        guid = self.e_guid.get().strip()
        color = self.e_color.get().strip()

        if not guid:
            return messagebox.showwarning("Fehler", "Bitte GUID eingeben.")
        if not color:
            return messagebox.showwarning("Fehler", "Bitte Farbe eingeben.")

        color_norm = self._normalize_color(color)
        if not color_norm:
            return messagebox.showwarning("Fehler", "Ung√ºltiges Farbformat. Erlaubt: # + 3..12 hex-Zeichen (z.B. #9D0001FF25).")

        # start background thread f√ºr die Request
        t = threading.Thread(target=self._do_claim, args=(guid, color_norm), daemon=True)
        t.start()

    def _do_claim(self, guid, color_norm):
        """
        Baut payload wie im Beispiel:
        payload = { "itemMetadata": "{\"NebulaData\":{\"Colors\":\"#FEFFFEFF\"}}" }
        und sendet PUT an /claim
        """
        try:
            profile_id = self.token_info.get("profile_id") or self.token_info.get("profileId")
            if not profile_id:
                self.after(0, self.write, "[FEHLER] profile_id nicht gefunden im token_info.", "red")
                return

            # safe URL-encoding: profile_id k√∂nnte bereits URL-codiert sein (z.B. DE%7C22969330)
            url = f"https://eu.mspapis.com/profilecollects/v3/profiles/{profile_id}/games/j68d/itemCollectTypes/summer_25_coco_hunt_12_quest_reward/itemCollects/{guid}/claim"

            # itemMetadata muss ein JSON-string sein (escaped JSON inside JSON)
            nebula = {"NebulaData": {"Colors": color_norm}}
            item_metadata_str = json.dumps(nebula)  # z.B. '{"NebulaData": {"Colors": "#FEFFFEFF"}}'
            payload = {"itemMetadata": item_metadata_str}

            headers = {
                "Authorization": f"Bearer {self.token_info.get('access_token')}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }

            self.after(0, self.write, f"[INFO] Claim request an {url} mit color {color_norm}", "yellow")
            # API erwartet PUT (nicht POST) ‚Äî deshalb PUT verwenden
            res = self.scraper.put(url, headers=headers, json=payload, timeout=12)
            res.raise_for_status()

            data = res.json()
            guid_resp = data.get("guid") or data.get("inventoryItemId")
            pretty = json.dumps(data, indent=2, ensure_ascii=False)
            self.after(0, self.write, f"[OK] Claim erfolgreich: guid={guid_resp}\n{pretty}", "green")
        except Exception as e:
            try:
                txt = res.text
            except Exception:
                txt = "(no response body)"
            self.after(0, self.write, f"[FEHLER] Claim fehlgeschlagen: {e} -- {txt}", "red")

    def write(self, msg, color=None):
        tag = None
        if color:
            try:
                self.log.tag_config(color, foreground=color)
                tag = color
            except Exception:
                tag = None
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)


class LoginCalendarTab(ttk.Frame):
    """
    Login-Calendar (monatliche Login-Ziele) claimen:
    - Manuell: Login + Claim Completed Goals
    - Automatisch: Claim f√ºr Accounts aus Datei (1-7)
    - API: https://eu.myown.com
    """

    API_HOST = "https://eu.mspapis.com"

    def __init__(self, master):
        super().__init__(master)
        self.scrapers = {}      # username -> scraper
        self.accounts = []      # token_info dicts
        self.goals_by_profile = {}  # profile_id -> list of goals
        self._build()

    def _build(self):
        pad = 6

        # Manuelles Login
        lf = ttk.LabelFrame(self, text="Manuell Login & Claim")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0,"DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Login & Claim Completed Goals", command=self.manual_login_claim).grid(row=3, columnspan=2, pady=pad)

        # Automatisch aus Account-Liste
        lf2 = ttk.LabelFrame(self, text="Automatisch Claim aus Liste")
        lf2.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf2, text="Liste ausw√§hlen (1-7)").grid(row=0, column=0, sticky="w")
        self.combo_list = ttk.Combobox(lf2, values=["1","2","3","4","5","6","7"], state="readonly", width=5)
        self.combo_list.set("1")
        self.combo_list.grid(row=0, column=1, padx=pad)

        ttk.Button(lf2, text="Start Claim f√ºr Liste", command=self.start_list_claim).grid(row=1, columnspan=2, pady=pad)

        # Combobox um Account anzuzeigen
        ttk.Label(self, text="Aktiver Account").pack(anchor="w", padx=pad)
        self.account_combo = ttk.Combobox(self, values=[], state="readonly")
        self.account_combo.pack(fill="x", padx=pad, pady=(0,6))

        # Goals Listbox
        self.goal_listbox = tk.Listbox(self, selectmode=tk.EXTENDED, height=10)
        self.goal_listbox.pack(fill="both", expand=False, padx=pad, pady=(0,6))

        # Log
        ttk.Label(self, text="Log").pack(anchor="w", padx=pad)
        self.log = ScrolledText(self, height=12, bg="#000000", fg="white", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    # ---------- Hilfsfunktionen ----------
    def get_scraper(self, username):
        return self.scrapers.get(username) or cloudscraper.create_scraper()

    def assign_scraper(self, username):
        scraper = cloudscraper.create_scraper()
        self.scrapers[username] = scraper

    def _update_account_combo(self):
        names = [a.get("username") for a in self.accounts]
        self.account_combo["values"] = names
        if names and self.account_combo.get() == "":
            self.account_combo.set(names[-1])

    def write(self, msg, color=None):
        try:
            self.log.insert(tk.END, msg + "\n")
            self.log.see(tk.END)
        except Exception:
            pass

    # ---------- Manuelles Login + Claim ----------
    def manual_login_claim(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()
        if not all([u,p,c]):
            return messagebox.showwarning("Fehler","Alle Felder ausf√ºllen!")
        threading.Thread(target=self._manual_worker, args=(u,p,c), daemon=True).start()

    def _manual_worker(self, u, p, c):
        try:
            self.assign_scraper(u)
            scraper = self.get_scraper(u)
            token_info = login(u,p,c,proxies=scraper.proxies)
            token_info["username"] = u
            self.scrapers[u] = scraper
            self.accounts.append(token_info)
            self.after(0,self._update_account_combo)
            self.after(0,self.write,f"[Login] {u} ({token_info.get('profile_id')})", "green")
            # Fetch Goals
            self._fetch_goals_worker(token_info)
            # Claim Completed Goals
            self._claim_all_worker(token_info)
        except Exception as e:
            self.after(0,self.write,f"[FEHLER Login] {u}: {e}", "red")
            self.after(0, lambda: messagebox.showerror("Login fehlgeschlagen", str(e)))

    # ---------- Account-Liste automatisch ----------
    def start_list_claim(self):
        file_id = self.combo_list.get()
        suffix = '' if file_id=='1' else file_id
        filename = f"acclist{suffix}.txt"
        threading.Thread(target=self._list_claim_worker, args=(filename,), daemon=True).start()

    def _list_claim_worker(self, filename):
        try:
            with open(filename,"r",encoding="utf-8") as f:
                for line in f:
                    parts = line.strip().split(":")
                    if len(parts)<2: continue
                    u, p = parts[0], parts[1]
                    c = parts[2] if len(parts)>=3 else "DE"
                    try:
                        self.assign_scraper(u)
                        scraper = self.get_scraper(u)
                        token_info = login(u,p,c,proxies=scraper.proxies)
                        token_info["username"] = u
                        self.accounts.append(token_info)
                        self.after(0,self._update_account_combo)
                        self.after(0,self.write,f"[Login] {u} ({token_info.get('profile_id')})", "green")
                        self._fetch_goals_worker(token_info)
                        self._claim_all_worker(token_info)
                    except Exception as e:
                        self.after(0,self.write,f"[FEHLER] {u}: {e}", "red")
                    time.sleep(0.5)
        except Exception as e:
            self.after(0,self.write,f"[FEHLER Datei] {filename}: {e}", "red")

    # ---------- Fetch Goals ----------
    def _fetch_goals_worker(self, token_info):
        profile_id = token_info.get("profile_id") or token_info.get("profileId")
        if not profile_id:
            self.after(0,self.write,f"[FEHLER] profile_id fehlt f√ºr {token_info.get('username')}", "red")
            return
        enc_pid = urllib.parse.quote(profile_id,safe='')
        url = f"{self.API_HOST}/logincalendar/v1/games/j68d/profiles/{enc_pid}/logincalendars/logincalendar-monthly"
        headers = {"Authorization":f"Bearer {token_info.get('access_token')}","Accept":"application/json"}
        scraper = self.get_scraper(token_info.get("username"))
        try:
            res = scraper.get(url,headers=headers,timeout=12)
            res.raise_for_status()
            data = res.json()
            goals = data.get("goals",[])
            self.goals_by_profile[profile_id] = goals
            self.after(0,self.write,f"[OK] {token_info.get('username')}: {len(goals)} goals geladen","green")
        except Exception as e:
            self.after(0,self.write,f"[FEHLER Fetch] {token_info.get('username')}: {e}", "red")

    # ---------- Claim Completed Goals ----------
    def _claim_all_worker(self, token_info):
        profile_id = token_info.get("profile_id") or token_info.get("profileId")
        goals = self.goals_by_profile.get(profile_id,[])
        completed_goals = [g for g in goals if g.get("status")=="Completed"]
        for goal in completed_goals:
            threading.Thread(target=self._claim_goal_worker,args=(token_info,profile_id,goal),daemon=True).start()
            time.sleep(0.5)

    def _claim_goal_worker(self, token_info, profile_id, goal):
        goalId = goal.get("goalId")
        if not goalId: return
        enc_pid = urllib.parse.quote(profile_id,safe='')
        url = f"{self.API_HOST}/logincalendar/v1/games/j68d/profiles/{enc_pid}/logincalendars/logincalendar-monthly/goals/{goalId}"
        headers = {"Authorization":f"Bearer {token_info.get('access_token')}","Content-Type":"application/json","Accept":"application/json"}
        scraper = self.get_scraper(token_info.get("username"))
        attempts = 0
        while attempts<3:
            attempts+=1
            try:
                res = scraper.post(url,headers=headers,json={},timeout=12)
                if res.status_code in (200,201,204):
                    self.after(0,self.write,f"[OK] Claimed {goalId}","green")
                    goal["status"]="Claimed"
                    return
                else:
                    time.sleep(0.5)
            except Exception as e:
                self.after(0,self.write,f"[FEHLER Claim] {token_info.get('username')}: {goalId}: {e} (Versuch {attempts}/3)","red")
                time.sleep(0.5)
        self.after(0,self.write,f"[FEHLER] {token_info.get('username')}: {goalId} konnte nach 3 Versuchen nicht geclaimed werden","red")


# -------------------- Main Window --------------------
class MSP2Toolkit(tk.Tk):
    def __init__(self):
        super().__init__()
        self.iconbitmap(resource_path("rabbit.ico"))
        setup_style(self)
        self.title("NiveDev v2.5")
        self.geometry("740x770")
        # Logo laden und anzeigen
        img = Image.open(resource_path("rabbit.jpg"))
        img = img.resize((60, 60), Image.LANCZOS)
        self.logo_img = ImageTk.PhotoImage(img)
        ttk.Label(self, image=self.logo_img, anchor="center").pack(pady=(10, 0))

        wrapper = ttk.Frame(self); wrapper.pack(fill="both", expand=True)
        nb = ttk.Notebook(wrapper); nb.pack(pady=12)
        #nb.add(LoveItTab(nb), text="‚ù§Ô∏è LoveIt")
        #nb.add(TokenRunnerTab(nb), text="üîë Token")
        nb.add(MoodTab(nb), text="Mood")
        nb.add(GenderSwitchTab(nb), text="Gender")
        nb.add(AutographTab(nb), text="Autos")
        nb.add(GiftOpenerTab(nb), text="Dupe")
        nb.add(DailyLogin(nb), text="DailyLogin")
        nb.add(TeleportTab(nb), text="TP")
        nb.add(SpecialMassSenderTab(nb), text="Stars")
        nb.add(StarGreetingComboTab(nb), text="DFW")
        nb.add(PasswordChangeTab(nb), text="PW")
        #nb.add(GiftDoubleSenderTab(nb), text="TE")
        nb.add(MonsterTab(nb), text="Monster")
        #nb.add(EventClaimQuestTab(nb), text="EventClaim")
        #nb.add(MultiGreetingTab(nb), text="AGS")
        nb.add(PetColorRedeemTab(nb), text="CopyPet")
        nb.add(LoginCalendarTab(nb), text="LoginItems")

if __name__ == "__main__":
    MSP2Toolkit().mainloop()
