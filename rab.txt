import json, time, random, queue, threading, base64
from typing import List, Dict, Optional
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
from tkinter.scrolledtext import ScrolledText
import requests, cloudscraper
import binascii
import struct
import zlib
import os
import sys
import random
import uuid
import urllib.parse
import threading
from concurrent.futures import ThreadPoolExecutor
from PIL import Image, ImageTk
from auth import login
from ugc  import load_ugcs, loveit

def resource_path(relative_path):
    base_path = getattr(sys, '_MEIPASS', os.path.abspath(os.path.dirname(__file__)))
    return os.path.join(base_path, relative_path)

# --- kleiner, animierter ToggleSwitch (Canvas) ---
class AnimatedToggleSwitch(ttk.Frame):
    def __init__(self, master, value=False, on_toggle=None, width=44, height=24):
        super().__init__(master)
        self.on_toggle = on_toggle
        self.w = width
        self.h = height
        self.pad = 2
        self._is_on = bool(value)
        self._animating = False

        self.canvas = tk.Canvas(self, width=self.w, height=self.h, highlightthickness=0, bg=self._bg())
        self.canvas.pack()
        self.canvas.bind("<Button-1>", self._click)

        # IDs
        self._track_id = None
        self._knob_id  = None
        self._draw_static()
        self._place_knob(instant=True)

    def set(self, value: bool, trigger: bool = True):
        """Extern Status setzen (ohne Animation)."""
        self._is_on = bool(value)
        self._place_knob(instant=True)
        if trigger and self.on_toggle:
            self.on_toggle(self._is_on)

    def _bg(self):
        """Hintergrundfarbe robust ermitteln (ttk-sicher)."""
        try:
            return self.master.cget("background")
        except Exception:
            pass
        try:
            style = ttk.Style()
            try:
                style_name = self.master.cget("style") or ""
            except Exception:
                style_name = ""
            candidates = [style_name, self.master.winfo_class(), "TFrame", "TLabelframe"]
            for name in candidates:
                if not name:
                    continue
                col = style.lookup(name, "background")
                if col:
                    return col
        except Exception:
            pass
        return "#FFFFFF"

    def _draw_static(self):
        self.canvas.delete("all")
        radius = self.h / 2
        fill = "#22c55e" if self._is_on else "#4b5563"
        self._track_id = self._round_rect(self.pad, self.pad, self.w - self.pad, self.h - self.pad,
                                          radius - 2, fill=fill, outline="")
        size = self.h - 2 * self.pad
        self._knob_id = self.canvas.create_oval(self.pad, self.pad, self.pad + size, self.pad + size,
                                                fill="#FFFFFF", outline="")

    def _round_rect(self, x1, y1, x2, y2, r, **kwargs):
        points = [
            x1 + r, y1, x2 - r, y1,
            x2, y1, x2, y1 + r,
            x2, y2 - r, x2, y2,
            x2 - r, y2, x1 + r, y2,
            x1, y2, x1, y2 - r,
            x1, y1 + r, x1, y1,
        ]
        return self.canvas.create_polygon(points, smooth=True, **kwargs)

    def _click(self, _evt=None):
        if self._animating:
            return
        target = not self._is_on
        self._animate_to(target)

    def _place_knob(self, instant=False):
        size = self.h - 2 * self.pad
        left_x  = self.pad
        right_x = self.w - self.pad - size
        x = right_x if self._is_on else left_x
        self.canvas.coords(self._knob_id, x, self.pad, x + size, self.pad + size)
        self.canvas.itemconfig(self._track_id, fill="#22c55e" if self._is_on else "#4b5563")

    def _animate_to(self, target_on: bool):
        """Animiert zum Zielzustand und ruft den Callback NACH der Animation auf."""
        if target_on == self._is_on:
            # Nichts zu tun
            self._place_knob(instant=True)
            return

        self._animating = True
        steps = 8
        dur_ms = 90

        size = self.h - 2 * self.pad
        left_x  = self.pad
        right_x = self.w - self.pad - size

        # Start/Ziel
        coords = self.canvas.coords(self._knob_id)
        x_now = coords[0] if coords else (right_x if self._is_on else left_x)
        x_end = right_x if target_on else left_x
        delta = (x_end - x_now) / steps if steps else 0

        # Farbverlauf
        def hex_to_rgb(h):
            h = h.lstrip("#")
            return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))
        def rgb_to_hex(t):
            return f"#{t[0]:02x}{t[1]:02x}{t[2]:02x}"
        def lerp(a, b, t): return int(a + (b - a) * t)

        start_col = hex_to_rgb(self.canvas.itemcget(self._track_id, "fill") or ("#22c55e" if self._is_on else "#4b5563"))
        end_col   = hex_to_rgb("#22c55e" if target_on else "#4b5563")

        def step(i=0, x=x_now):
            t = i / steps if steps else 1
            r = lerp(start_col[0], end_col[0], t)
            g = lerp(start_col[1], end_col[1], t)
            b = lerp(start_col[2], end_col[2], t)
            self.canvas.itemconfig(self._track_id, fill=rgb_to_hex((r, g, b)))
            self.canvas.coords(self._knob_id, x, self.pad, x + size, self.pad + size)
            if i < steps:
                self.after(max(1, dur_ms // steps), step, i + 1, x + delta)
            else:
                # Ziel fixieren & Status √ºbernehmen
                self._is_on = target_on
                self._place_knob(instant=True)
                self._animating = False
                if self.on_toggle:
                    # Callback erst am Ende ausf√ºhren
                    try:
                        self.on_toggle(self._is_on)
                    except Exception:
                        pass

        step()


# -------------------- Style (dark blue) --------------------
def setup_style(root: tk.Tk):
    style = ttk.Style(root)
    style.theme_use("clam")

    # Schwarz-Rot-Farbschema
    bg  = "#000000"   # tiefes Schwarz
    fg  = "#ffffff"   # Wei√ü f√ºr Text
    acc = "#941515"   # kr√§ftiges Rot
    hl  = "#000000"   # dunkles Grau

    root.configure(bg=bg)
    style.configure(".", background=bg, foreground=fg, font=("Comic Sans MS", 10))
    style.configure("TFrame", background=bg)
    style.configure("TLabel", background=bg, foreground=fg)
    style.configure("TLabelFrame", background=bg, foreground=acc, font=("Comic Sans MS", 10, "bold"))
    style.configure("TButton", padding=6, relief="flat", background=acc, foreground="white")
    style.map("TButton", background=[("active", "#941515")])
    style.configure("TEntry", fieldbackground="#000000", foreground=fg, insertcolor=fg)
    style.configure("TNotebook", background=bg)
    style.configure("TNotebook.Tab", background=hl, foreground=fg, padding=(12, 6))
    style.map("TNotebook.Tab", background=[("selected", acc)], foreground=[("selected", "white")])


# -------------------- Shared Tokens -----------------------
shared_tokens: List[Dict] = []


# -------------------- LoveIt Tab --------------------------
class LoveItTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.ugcs: List[Dict] = []
        self.log_q, self.prog_q = queue.Queue(), queue.Queue()
        self._build(); self._poll()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login"); lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w"); 
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w"); 
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w"); 
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0,"DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3,columnspan=2,pady=pad)

        self.tok_var = tk.StringVar(value="Tokens: 0")
        ttk.Label(lf, textvariable=self.tok_var).grid(row=4,columnspan=2)

        tf = ttk.Frame(self); tf.pack(fill="x", padx=pad)
        ttk.Button(tf, text="Load tokens.json", command=self.load_tokens).pack(side="left", padx=pad)

        ugcf = ttk.LabelFrame(self, text="UGCs"); ugcf.pack(fill="both",expand=True,padx=pad,pady=pad)
        self.lb = tk.Listbox(ugcf, selectmode=tk.MULTIPLE, bg="#000000", fg="#ffffff")
        self.lb.pack(side="left",fill="both",expand=True)
        sb  = ttk.Scrollbar(ugcf, command=self.lb.yview); sb.pack(side="right",fill="y")
        self.lb.config(yscrollcommand=sb.set)

        cf = ttk.LabelFrame(self, text="‚ûï Custom ID"); cf.pack(fill="x", padx=pad)
        self.e_custom = ttk.Entry(cf); self.e_custom.pack(side="left",fill="x",expand=True,padx=pad)
        ttk.Button(cf, text="Add", command=self.add_custom).pack(side="right",padx=pad)

        bf = ttk.Frame(self); bf.pack(fill="x",padx=pad,pady=pad)
        self.btn_load = ttk.Button(bf,text="Load UGCs (first token)",command=self.load_ugcs); self.btn_load.pack(side="left",padx=pad)
        self.btn_love = ttk.Button(bf,text="Send LoveIt",state="disabled",command=self.start_worker); self.btn_love.pack(side="left",padx=pad)

        self.prog = ttk.Progressbar(self,maximum=100); self.prog.pack(fill="x",padx=pad)
        self.log  = ScrolledText(self, height=8, state="disabled", bg="#000000", fg="#ffffff", insertbackground="#ffffff")
        self.log.pack(fill="both",expand=True,padx=pad,pady=pad)

    def login_click(self):
        u,p,c = self.e_user.get().strip(), self.e_pw.get().strip(), self.e_cty.get().strip().upper()
        if not all([u,p,c]): return messagebox.showwarning("Input","Missing fields")
        try:
            info = login(u,p,c)
            shared_tokens.append(info); self.tok_var.set(f"Tokens: {len(shared_tokens)}")
            messagebox.showinfo("Login","Token saved")
        except Exception as e:
            messagebox.showerror("Login",str(e))

    def load_tokens(self):
        fp = filedialog.askopenfilename(title="tokens.json",filetypes=[("JSON","*.json")])
        if fp:
            try:
                data=json.load(open(fp,encoding="utf-8"))
                if isinstance(data,list):
                    shared_tokens.extend(data); self.tok_var.set(f"Tokens: {len(shared_tokens)}")
            except Exception as e:
                messagebox.showerror("tokens.json", str(e))

    def load_ugcs(self):
        if not shared_tokens: return
        tok=shared_tokens[0]
        try:
            self.ugcs=load_ugcs(tok["access_token"],tok["profile_id"])
        except Exception as e:
            return messagebox.showerror("UGCs",str(e))
        self.lb.delete(0,tk.END); [self.lb.insert(tk.END,f"{u['id']} | {u.get('title','')}") for u in self.ugcs]
        self.btn_love["state"]="normal"

    def add_custom(self):
        ids=[i for i in self.e_custom.get().replace(",", " ").split() if i]
        self.e_custom.delete(0,tk.END)
        for i in ids:
            if not any(u["id"]==i for u in self.ugcs):
                self.ugcs.append({"id":i}); self.lb.insert(tk.END,f"{i} | Custom")

    def start_worker(self):
        sel=[self.ugcs[i] for i in self.lb.curselection()]
        if not sel: return
        total=len(sel)*len(shared_tokens)
        self.prog.config(maximum=total,value=0)
        self.log.config(state="normal"); self.log.delete("1.0",tk.END); self.log.config(state="disabled")
        self.btn_love["state"]="disabled"
        threading.Thread(target=self.worker,args=(sel,total),daemon=True).start()

    def worker(self,sel,total):
        done=0
        for tok in shared_tokens:
            for u in sel:
                ok=loveit(tok["access_token"],tok["profile_id"],u["id"])
                self.log_q.put(f"[{'OK' if ok else 'FAIL'}] {u['id']}"); done+=1; self.prog_q.put(done)
        self.log_q.put("Finished"); self.prog_q.put(-1)

    def _poll(self):
        while not self.log_q.empty(): self._append(self.log_q.get())
        while not self.prog_q.empty():
            v=self.prog_q.get()
            if v==-1: self.btn_love["state"]="normal"
            else: self.prog["value"]=v
        self.after(100,self._poll)

    def _append(self,txt):
        self.log.config(state="normal"); self.log.insert(tk.END,txt+"\n"); self.log.see(tk.END); self.log.config(state="disabled")

# -------------------- Token Runner Tab --------------------
class TokenRunnerTab(ttk.Frame):
    LOGIN_URL    = "https://eu-secure.mspapis.com/loginidentity/connect/token"
    ACCOUNTS_FILE = "token.txt"     # <- LOKALE Datei mit user:pass:country
    PROXIES_FILE  = "proxies.txt"   # <- LOKALE Datei mit user:pass@host:port

    def __init__(self, master):
        super().__init__(master)
        self.running = False
        self.success = 0

        # Round-robin Proxies
        self.proxies = []
        self.proxy_idx = 0
        self.proxy_lock = threading.Lock()

        self.thread_count = tk.IntVar(value=3)
        self.delay_seconds = tk.IntVar(value=3)

        self._build()
        self._load_proxies()
        self._load_accounts()

    # ---------- UI ----------
    def _build(self):
        pad = 6

        top = ttk.Frame(self)
        top.pack(fill="x", padx=pad, pady=pad)

        self.btn = ttk.Button(top, text="Start", command=self.toggle)
        self.btn.pack(side="left", padx=pad)

        ttk.Button(top, text="üîÑ Proxies neu laden", command=self._load_proxies).pack(side="left", padx=pad)
        ttk.Button(top, text="üìÑ Accounts neu laden", command=self._load_accounts).pack(side="left", padx=pad)
        ttk.Button(top, text="Manual", command=self.manual_win).pack(side="left", padx=pad)

        self.lbl = ttk.Label(self, text="OK Tokens: 0", foreground="lightgreen")
        self.lbl.pack()

        tf = ttk.Frame(self)
        tf.pack(fill="x", padx=pad)

        ttk.Label(tf, text="Threads:").pack(side="left", padx=pad)
        ttk.Spinbox(tf, from_=1, to=50, textvariable=self.thread_count, width=5).pack(side="left")

        ttk.Label(tf, text="Delay (s):").pack(side="left", padx=pad)
        ttk.Spinbox(tf, from_=0, to=10, textvariable=self.delay_seconds, width=5).pack(side="left")

        self.log = ScrolledText(self, height=15, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

        # kleine Statuslabels
        stat = ttk.Frame(self); stat.pack(fill="x", padx=pad, pady=(0, pad))
        self.acc_count_var = tk.StringVar(value="Accounts: 0")
        self.prx_count_var = tk.StringVar(value="Proxies: 0")
        ttk.Label(stat, textvariable=self.acc_count_var).pack(side="left")
        ttk.Label(stat, textvariable=self.prx_count_var).pack(side="left", padx=12)

    # ---------- Logging ----------
    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

    def inc_ok(self):
        self.success += 1
        self.lbl.config(text=f"OK Tokens: {self.success}")

    # ---------- Daten laden ----------
    def _base_dir(self):
        return os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)

    def _load_proxies(self):
        path = os.path.join(self._base_dir(), self.PROXIES_FILE)
        self.proxies.clear()
        try:
            with open(path, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue
                    # Erwartetes Format: user:pass@host:port (dein Beispiel)
                    # z.B. user-NiveDev:Pwd@eu.lunaproxy.com:12233
                    if "@" in line and ":" in line:
                        # baue http(s) Proxy-URL
                        proxy_url = f"http://{line}"
                        self.proxies.append({"http": proxy_url, "https": proxy_url})
            self.prx_count_var.set(f"Proxies: {len(self.proxies)}")
            self.write(f"[proxies] geladen: {len(self.proxies)}", "cyan")
        except Exception as e:
            self.write(f"[proxies] Fehler beim Laden: {e}", "red")
            self.prx_count_var.set("Proxies: 0")

    def _load_accounts(self):
        self.accounts = []  # Liste von Tupeln (user, pass, country)
        path = os.path.join(self._base_dir(), self.ACCOUNTS_FILE)
        try:
            with open(path, "r", encoding="utf-8") as f:
                for line in f:
                    l = line.strip()
                    if not l or l.startswith("#"):
                        continue
                    parts = l.split(":")
                    if len(parts) == 1:
                        # nur username -> kein pass, skip
                        continue
                    if len(parts) == 2:
                        user, pw = parts
                        ctry = "de"
                    else:
                        user, pw, ctry = parts[0], parts[1], (parts[2] or "de")
                    self.accounts.append((user.strip(), pw.strip(), ctry.strip().lower()))
            self.acc_count_var.set(f"Accounts: {len(self.accounts)}")
            self.write(f"[accounts] geladen: {len(self.accounts)}", "cyan")
        except FileNotFoundError:
            self.write(f"[accounts] {self.ACCOUNTS_FILE} nicht gefunden", "red")
            self.acc_count_var.set("Accounts: 0")
        except Exception as e:
            self.write(f"[accounts] Fehler beim Laden: {e}", "red")
            self.acc_count_var.set("Accounts: 0")

    # ---------- Proxy RR ----------
    def _next_proxy(self):
        if not self.proxies:
            return None
        with self.proxy_lock:
            prx = self.proxies[self.proxy_idx % len(self.proxies)]
            self.proxy_idx += 1
            return prx

    # ---------- Worker ----------
    def worker(self, q: queue.Queue):
        timeout_streak = 0
        while self.running:
            try:
                u, p, c = q.get_nowait()
            except queue.Empty:
                break

            try:
                prx = self._next_proxy()
                info = login(u, p, c, proxies=prx)  # dein vorhandenes login() nutzt proxies=
                shared_tokens.append(info)
                self.write(f"[OK] {u}", "green")
                self.inc_ok()
                timeout_streak = 0
                time.sleep(self.delay_seconds.get())
            except requests.exceptions.Timeout:
                timeout_streak += 1
                self.write(f"[TIMEOUT] {u}", "orange")
                if timeout_streak >= 7:
                    self.write("[INFO] 7x Timeout ‚Üí Warte 30 Sekunden...", "yellow")
                    time.sleep(120)
                    timeout_streak = 0
            except Exception as e:
                self.write(f"[FAIL] {u} ({e})", "red")
                timeout_streak = 0

            q.task_done()

    # ---------- Start/Stop ----------
    def toggle(self):
        self.running = not self.running
        self.btn.config(text="Stop" if self.running else "Start")
        if not self.running:
            return

        if not getattr(self, "accounts", None):
            self._load_accounts()
        if not self.accounts:
            self.write("[WARN] Keine Accounts geladen.", "yellow")
            self.running = False
            self.btn.config(text="Start")
            return

        q = queue.Queue()
        for a in self.accounts:
            q.put(a)

        for _ in range(self.thread_count.get()):
            threading.Thread(target=self.worker, args=(q,), daemon=True).start()

    # ---------- Manual Login ----------
    def manual_win(self):
        w = tk.Toplevel(self)
        w.title("Manual")
        w.geometry("260x200")

        ttk.Label(w, text="User").pack()
        e_u = ttk.Entry(w); e_u.pack()

        ttk.Label(w, text="Pass").pack()
        e_p = ttk.Entry(w, show="*"); e_p.pack()

        ttk.Label(w, text="Country").pack()
        e_c = ttk.Entry(w); e_c.insert(0, "de"); e_c.pack()

        def run():
            try:
                prx = self._next_proxy()
                info = login(e_u.get(), e_p.get(), e_c.get(), proxies=prx)
                shared_tokens.append(info)
                self.write("[OK] manual", "green")
                self.inc_ok()
            except Exception as e:
                self.write(f"[FAIL] manual ({e})", "red")
            w.destroy()

        ttk.Button(w, text="Login", command=run).pack(pady=8)

# -------------------- Gender Switch Tab --------------------
class GenderSwitchTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.token_info = None
        self.scraper = cloudscraper.create_scraper()
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login"); lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0,"DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        self.gender_var = tk.StringVar(value="Geschlecht: Unbekannt")
        ttk.Label(self, textvariable=self.gender_var).pack(pady=pad)

        ttk.Button(self, text="üîÑ Geschlecht wechseln", command=self.toggle_gender).pack(pady=pad)

        self.log = ScrolledText(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")

        try:
            self.token_info = login(u, p, c)  # liefert access_token + profile_id
            gender = self.get_gender()
            self.gender_var.set(f"Geschlecht: {gender}")
            self.write(f"[OK] Eingeloggt als {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def get_gender(self):
        url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{self.token_info['profile_id']}/games/j68d/attributes"
        headers = {
            "Authorization": f"Bearer {self.token_info['access_token']}",
            "Accept": "application/json"
        }
        r = self.scraper.get(url, headers=headers)
        r.raise_for_status()
        data = r.json()
        return data.get("additionalData", {}).get("Gender", "Unbekannt")

    def toggle_gender(self):
        if not self.token_info:
            return messagebox.showwarning("Nicht eingeloggt", "Bitte zuerst einloggen.")

        try:
            url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{self.token_info['profile_id']}/games/j68d/attributes"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Accept": "application/json"
            }

            # Aktuellen Status abrufen
            r = self.scraper.get(url, headers=headers)
            r.raise_for_status()
            data = r.json()

            current_gender = data["additionalData"].get("Gender", "Boy")
            new_gender = "Girl" if current_gender == "Boy" else "Boy"
            data["additionalData"]["Gender"] = new_gender

            headers["Content-Type"] = "application/json"
            put = self.scraper.put(url, headers=headers, json=data)
            put.raise_for_status()

            self.gender_var.set(f"Geschlecht: {new_gender}")
            self.write(f"[OK] Geschlecht ge√§ndert zu {new_gender}", "green")
            self.write(f"Logge dich neu ein!", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Fehler", str(e))

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

# -------------------- Autograph Tab --------------------
class AutographTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.accounts = []
        self.scraper = cloudscraper.create_scraper()
        self.auto_running = False
        self.auto_thread = None
        self._build()
        self._start_token_refresh_thread()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf)
        self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*")
        self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf)
        self.e_cty.insert(0, "DE")
        self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)
        ttk.Button(lf, text="üìú ListeLogin", command=lambda: self.login_from_file("autograph.txt")).grid(row=4, columnspan=2, pady=(0, pad))
        ttk.Button(lf, text="üìú ListeLogin2", command=lambda: self.login_from_file("autograph2.txt")).grid(row=5, columnspan=2, pady=(0, pad))

        self.account_list = tk.Listbox(self, height=4, bg="#000000", fg="white", selectbackground="#000000", selectforeground="white")
        self.account_list.pack(fill="x", padx=pad, pady=(pad, 0))

        ttk.Button(self, text="‚ùå Entfernen", command=self.remove_selected_account).pack(pady=(0, pad))

        targetf = ttk.LabelFrame(self, text="Autogramm senden an:")
        targetf.pack(fill="x", padx=pad, pady=pad)

        self.e_target = ttk.Entry(targetf)
        self.e_target.pack(fill="x", padx=pad, pady=pad)

        ttk.Button(self, text="‚ñ∂Ô∏è Start", command=self.start_auto).pack(pady=pad)
        ttk.Button(self, text="‚èπÔ∏è Stop", command=self.stop_auto).pack(pady=(0, pad))

        self.log = ScrolledText(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_from_file(self, filename):
        try:
            base_dir = os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)
            full_path = os.path.join(base_dir, filename)
            self.write(f"[DEBUG] Suche Datei: {full_path}", "yellow")

            with open(full_path, "r", encoding="utf-8") as f:
                lines = f.readlines()

            for line in lines:
                parts = line.strip().split(":")
                if len(parts) < 2:
                    continue
                u = parts[0].strip()
                p = parts[1].strip()
                c = parts[2].strip().upper() if len(parts) > 2 else "DE"
                try:
                    token_info = login(u, p, c)
                    token_info["username"] = u
                    token_info["password"] = p
                    token_info["country"] = c
                    self.accounts.append(token_info)
                    self.account_list.insert(tk.END, u)
                    self.write(f"[OK] Eingeloggt als {u}", "green")
                except Exception as e:
                    self.write(f"[FEHLER] {u}: {e}", "red")

        except Exception as e:
            self.write(f"[FEHLER] Datei konnte nicht gelesen werden: {e}", "red")

    def remove_selected_account(self):
        selected = self.account_list.curselection()
        if not selected:
            return
        index = selected[0]
        acc = self.accounts[index]
        self.write(f"[INFO] Account entfernt: {acc['username']}", "yellow")
        self.account_list.delete(index)
        del self.accounts[index]

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        if int(self.log.index("end-1c").split(".")[0]) > 50:
            self.log.delete("1.0", "2.0")
        self.log.see(tk.END)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")
        try:
            token_info = login(u, p, c)
            token_info["username"] = u
            token_info["password"] = p
            token_info["country"] = c
            self.accounts.append(token_info)
            self.account_list.insert(tk.END, u)
            self.write(f"[OK] Eingeloggt als {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def find_profile_id(self, username, region):
        try:
            url = "https://eu.mspapis.com/edgerelationships/graphql/graphql"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Content-Type": "application/json"
            }
            query = """
            query GetProfileSearch($region: String!, $startsWith: String!, $pageSize: Int, $currentPage: Int, $preferredGameId: String!) {
                findProfiles(region: $region, nameBeginsWith: $startsWith, pageSize: $pageSize, page: $currentPage) {
                    totalCount
                    nodes {
                        id
                        avatar(preferredGameId: $preferredGameId) {
                            gameId
                            face
                            full
                        }
                    }
                }
            }
            """
            variables = {
                "region": region,
                "startsWith": username,
                "pageSize": 50,
                "currentPage": 1,
                "preferredGameId": "j68d"
            }
            payload = {"query": query, "variables": variables}
            r = self.scraper.post(url, headers=headers, json=payload)
            r.raise_for_status()
            data = r.json()
            nodes = data.get("data", {}).get("findProfiles", {}).get("nodes", [])
            if not nodes:
                self.write(f"[FEHLER] Kein Profil mit dem Namen '{username}' gefunden.", "red")
                return None
            return nodes[0]["id"]
        except Exception as e:
            self.write(f"[FEHLER] Profil-ID konnte nicht ermittelt werden: {e}", "red")
            return None

    def send_autograph(self, token_info, receiver_id, target_name):
        try:
            url = "https://eu.mspapis.com/federationgateway/graphql"
            headers = {
                "Authorization": f"Bearer {token_info['access_token']}",
                "Content-Type": "application/json"
            }
            payload = {
                "id": "SendGreetings-159BDD7706D824BB8F14874A7FAE3368",
                "variables": {
                    "greetingType": "Autograph",
                    "receiverProfileId": receiver_id,
                    "ignoreDailyCap": False
                }
            }
            r = self.scraper.post(url, headers=headers, json=payload)
            r.raise_for_status()
            data = r.json()
            success = data.get("data", {}).get("greetings", {}).get("sendGreeting", {}).get("success", False)
            if success:
                self.write(f"[OK] Autogramm an {target_name} gesendet von {token_info['username']}", "green")
            else:
                self.write(f"[FEHLER] Autogramm von {token_info['username']} konnte nicht gesendet werden", "red")
        except Exception as e:
            self.write(f"[FEHLER] {token_info['username']}: {e}", "red")

    def start_auto(self):
        if not self.accounts:
            return messagebox.showwarning("Keine Accounts", "Bitte mindestens einen Account anmelden.")
        if not self.e_target.get().strip():
            return messagebox.showwarning("Fehler", "Zielbenutzer eingeben!")

        self.auto_running = True
        self.auto_thread = threading.Thread(target=self.auto_loop, daemon=True)
        self.auto_thread.start()
        self.write("[INFO] Automatisches Versenden gestartet...", "green")

    def stop_auto(self):
        self.auto_running = False
        self.write("[INFO] Automatisches Versenden gestoppt.", "yellow")

    def auto_loop(self):
        while self.auto_running:
            target_name = self.e_target.get().strip()
            if not target_name:
                self.write("[FEHLER] Kein Zielbenutzer gesetzt.", "red")
                break
            for acc in self.accounts:
                self.token_info = acc
                profile_id = self.find_profile_id(target_name, acc["country"])
                if profile_id:
                    self.send_autograph(acc, profile_id, target_name)
                time.sleep(1)
            for _ in range(120):
                if not self.auto_running:
                    break
                time.sleep(1)

    def _start_token_refresh_thread(self):
        def refresh_loop():
            while True:
                time.sleep(3600)
                for i, acc in enumerate(self.accounts):
                    try:
                        new_token = login(acc["username"], acc["password"], acc["country"])
                        new_token["username"] = acc["username"]
                        new_token["password"] = acc["password"]
                        new_token["country"] = acc["country"]
                        self.accounts[i] = new_token
                        self.write(f"[REFRESH] Token erneuert f√ºr {acc['username']}", "cyan")
                    except Exception as e:
                        self.write(f"[FEHLER] Token-Erneuerung fehlgeschlagen f√ºr {acc['username']}: {e}", "red")
        threading.Thread(target=refresh_loop, daemon=True).start()

# -------------------- Duplication --------------------
class GiftOpenerTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.accounts = []
        self.threads = []
        self.start_event = threading.Event()
        self._build()

    def _build(self):
        pad = 6

        lf = ttk.LabelFrame(self, text="Logins einzeln")
        lf.pack(fill="x", padx=pad, pady=pad)

        for i in range(2):
            ttk.Label(lf, text=f"Benutzer {i+1}").grid(row=i*4, column=0, sticky="w")
            setattr(self, f"e_user{i}", ttk.Entry(lf))
            getattr(self, f"e_user{i}").grid(row=i*4, column=1, padx=pad)

            ttk.Label(lf, text="Passwort").grid(row=i*4+1, column=0, sticky="w")
            setattr(self, f"e_pw{i}", ttk.Entry(lf, show="*"))
            getattr(self, f"e_pw{i}").grid(row=i*4+1, column=1, padx=pad)

            ttk.Label(lf, text="Land").grid(row=i*4+2, column=0, sticky="w")
            e_cty = ttk.Entry(lf); e_cty.insert(0, "DE")
            setattr(self, f"e_cty{i}", e_cty)
            e_cty.grid(row=i*4+2, column=1, padx=pad)

            ttk.Button(lf, text=f"Login Benutzer {i+1}", command=lambda idx=i: self.login_click(idx)).grid(row=i*4+3, columnspan=2, pady=pad)

        gf = ttk.LabelFrame(self, text="üéÅ Geschenk √∂ffnen")
        gf.pack(fill="x", padx=pad, pady=pad)

        for i in range(2):
            ttk.Label(gf, text=f"Gift-ID f√ºr Benutzer {i+1}").grid(row=i, column=0)
            setattr(self, f"e_gift{i}", ttk.Entry(gf))
            getattr(self, f"e_gift{i}").grid(row=i, column=1, padx=pad)

        ttk.Button(self, text="üß† Threads vorbereiten", command=self.open_gifts).pack(pady=pad)
        ttk.Button(self, text="üéØ Jetzt starten", command=self.start_event.set).pack(pady=pad)

        self.log = tk.Text(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self, idx):
        u = getattr(self, f"e_user{idx}").get().strip()
        p = getattr(self, f"e_pw{idx}").get().strip()
        c = getattr(self, f"e_cty{idx}").get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")

        try:
            for i in range(2):  # doppelt einloggen
                token_info = login(u, p, c)
                token_info["username"] = u
                token_info["country"] = c
                self.accounts.append(token_info)
            self.write(f"[OK] Benutzer {idx+1} doppelt eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login Benutzer {idx+1}: {e}", "red")
            messagebox.showerror("Login", str(e))

    def open_gifts(self):
        self.threads.clear()
        self.start_event.clear()

        for idx in range(len(self.accounts)):
            for _ in range(35):  # volle Power f√ºr jede Session
                t = threading.Thread(target=self.open_single_gift, args=(idx,), daemon=True)
                self.threads.append(t)

        for t in self.threads:
            t.start()

        self.write("[INFO] Alle Threads bereit. Warte auf Startsignal...", "yellow")

    def open_single_gift(self, idx):
        acc = self.accounts[idx]
        if not acc:
            self.write(f"[FEHLER] Benutzer {idx+1} nicht eingeloggt", "red")
            return

        gift_id_index = 0 if idx < 2 else idx % 2
        gift_id = getattr(self, f"e_gift{gift_id_index}").get().strip()
        if not gift_id:
            self.write(f"[FEHLER] Keine Gift-ID f√ºr Benutzer {gift_id_index+1} angegeben", "red")
            return

        self.start_event.wait()  # Synchronstart f√ºr alle Threads

        payload = {
            "query": """
            mutation OpenGift($giftId: ID!, $receiverProfileId: ID!) {
                openGift(input: {
                    giftId: $giftId,
                    receiverProfileId: $receiverProfileId
                }) {
                    success
                    error
                    item {
                        id
                        objectId
                        objectSource
                        additionalData
                        tags {
                            id
                            source
                        }
                    }
                }
            }
            """,
            "variables": {
                "giftId": gift_id,
                "receiverProfileId": acc["profile_id"]
            }
        }

        headers = {
            "Authorization": f"Bearer {acc['access_token']}",
            "Content-Type": "application/json",
            "Referer": "https://moviestarplanet2.com/",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36"
        }

        try:
            res = self.scraper.post(
                "https://eu.mspapis.com/edgegifts/graphql/graphql",
                headers=headers,
                json=payload,
                timeout=6  # aggressiver Timeout
            )
            res.raise_for_status()
            data = res.json()["data"]["openGift"]
            if data["success"]:
                item_id = data["item"]["id"]
                self.after(0, self.write, f"[OK] Geschenk {gift_id} ge√∂ffnet f√ºr {acc['username']} (Item ID: {item_id})", "green")
            else:
                error = data["error"]
                self.after(0, self.write, f"[FEHLER] Geschenk nicht ge√∂ffnet f√ºr {acc['username']}: {error}", "red")
        except Exception as e:
            self.after(0, self.write, f"[FEHLER] Fehler bei {acc['username']}: {e}", "red")

    def write(self, msg, color=None):
        self.log.insert(tk.END, msg + "\n")
        self.log.see(tk.END)


# -------------------- Daily Login --------------------
class DailyLogin(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.accounts = []
        self._build()

    def _build(self):
        pad = 6

        ttk.Label(self, text="üìÑ Accountliste ausw√§hlen").pack(pady=(8, 2))
        self.combo_claim = ttk.Combobox(
            self, values=["1", "2", "3", "4", "5", "6", "7"], state="readonly", width=5)
        self.combo_claim.set("1")
        self.combo_claim.pack()

        ttk.Button(self, text="üìú Liste einloggen", command=self.login_from_file).pack(pady=(4, pad))

        self.log = tk.Text(self, height=16, bg="#000000", fg="white", insertbackground="#ffffff")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_from_file(self):
        file_id = self.combo_claim.get()
        suffix = '' if file_id == '1' else file_id
        dateiname = resource_path(f"kokosnuss{suffix}.txt")

        # ‚Üí holt den Pfad der EXE oder des Skripts
        base_dir = os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)
        dateiname = os.path.join(base_dir, f"kokosnuss{suffix}.txt")

        # üëá Debug-Ausgabe f√ºr den gesuchten Dateipfad
        self.write(f"[DEBUG] Suche Datei: {dateiname}", "yellow")

        def worker():
            try:
                with open(dateiname, "r", encoding="utf-8") as f:
                    lines = [line.strip() for line in f if line.strip()]
                for line in lines:
                    parts = line.split(":")
                    if len(parts) < 2:
                        continue
                    u, p = parts[0], parts[1]
                    c = parts[2] if len(parts) >= 3 else "DE"
                    try:
                        scraper = cloudscraper.create_scraper()
                        token_info = login(u, p, c, proxies=scraper.proxies)
                        token_info["username"] = u
                        self.accounts.append(token_info)
                        self.write(f"[Login] {u}", "green")
                    except Exception as e:
                        self.write(f"[FEHLER] {u}: {e}", "red")
                    time.sleep(0.5)
                self.write("‚úÖ Liste abgeschlossen. Weitere Liste nur manuell starten.", "cyan")
            except Exception as e:
                self.write(f"[FEHLER] Datei: {e}", "red")

        threading.Thread(target=worker, daemon=True).start()

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_configure(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)


# -------------------- Teleport Tab --------------------
class TeleportTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.token_info = None
        self.scraper = cloudscraper.create_scraper()
        self.attributes = {}
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf)
        self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*")
        self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf)
        self.e_cty.insert(0, "DE")
        self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        pos_frame = ttk.LabelFrame(self, text="Neue Koordinaten")
        pos_frame.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(pos_frame, text="X").grid(row=0, column=0)
        self.e_x_int = ttk.Entry(pos_frame, width=5)
        self.e_x_int.insert(0, "15")
        self.e_x_int.grid(row=0, column=1, padx=4)

        ttk.Label(pos_frame, text="Y").grid(row=0, column=2)
        self.e_y_int = ttk.Entry(pos_frame, width=5)
        self.e_y_int.insert(0, "-1")
        self.e_y_int.grid(row=0, column=3, padx=4)

        ttk.Label(pos_frame, text="Z").grid(row=0, column=4)
        self.e_z_int = ttk.Entry(pos_frame, width=5)
        self.e_z_int.insert(0, "-16")
        self.e_z_int.grid(row=0, column=5, padx=4)

        ttk.Label(self, text="üåç Raumtyp w√§hlen").pack(pady=(4, 0))
        self.room_type = ttk.Combobox(self, state="readonly", values=[
            "summer_22_plaza",
            "summer_desert",
            "summer_festival_city_beach",
            "summer_festival_vip_club"
        ])
        self.room_type.set("summer_22_plaza")
        self.room_type.pack(pady=(0, pad))

        ttk.Button(self, text="üõ∞Ô∏è Teleportieren", command=self.teleport).pack(pady=pad)

        self.log = ScrolledText(self, height=10, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()

        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")

        try:
            self.token_info = login(u, p, c)
            self.token_info["username"] = u
            self.write(f"[OK] Eingeloggt als {u}", "green")
            self.load_attributes()
        except Exception as e:
            self.write(f"[FEHLER] {e}", "red")
            messagebox.showerror("Login", str(e))

    def load_attributes(self):
        profile_id = self.token_info['profile_id']
        token = self.token_info['access_token']
        url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{profile_id}/games/j68d/attributes"
        headers = {
            "Authorization": f"Bearer {token}",
            "Accept": "application/json"
        }
        try:
            r = self.scraper.get(url, headers=headers)
            r.raise_for_status()
            data = r.json()
            self.attributes = data.get("additionalData", {})
            self.write("[INFO] Daten erfolgreich geladen.", "cyan")
        except Exception as e:
            self.write(f"[FEHLER] Daten konnten nicht geladen werden: {e}", "red")

    def teleport(self):
        if not self.token_info or not self.attributes:
            return messagebox.showwarning("Fehler", "Bitte zuerst einloggen und Daten laden.")

        try:
            # Sichtbare Eingaben
            x_int = int(self.e_x_int.get())
            y_int = int(self.e_y_int.get())
            z_int = int(self.e_z_int.get())

            # Fest hinterlegte Nachkommastellen
            x_float = float(f"{x_int}.83926010131836")
            y_float = float(f"{y_int}.5668649077415466")
            z_float = float(f"{z_int}.73294997215271")

        except ValueError:
            return messagebox.showerror("Fehler", "Ung√ºltige Zahlen (nur ganze Zahlen erlaubt).")

        try:
            profile_id = self.token_info['profile_id']
            token = self.token_info['access_token']
            url = f"https://eu.mspapis.com/profileattributes/v1/profiles/{profile_id}/games/j68d/attributes"
            headers = {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            }

            payload = {
                "additionalData": dict(self.attributes)
            }

            pos_data = json.loads(payload["additionalData"].get("ChatRoomPositionData", "{}"))
            pos_data["position"] = {"x": x_float, "y": y_float, "z": z_float}
            pos_data["roomType"] = self.room_type.get()
            payload["additionalData"]["ChatRoomPositionData"] = json.dumps(pos_data)

            res = self.scraper.put(url, headers=headers, json=payload)
            if res.status_code == 200:
                self.write(f"[OK] Teleportiert nach {self.room_type.get()} ‚Üí X:{x_float} Y:{y_float} Z:{z_float}", "green")
            else:
                self.write(f"[FEHLER] Teleport fehlgeschlagen: {res.status_code}", "red")
        except Exception as e:
            self.write(f"[FEHLER] Teleport fehlgeschlagen: {e}", "red")

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_configure(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)


# -------------------- Star Greeting Combo Tab --------------------
class StarGreetingComboTab(ttk.Frame):
    """
    Kombi-Tool mit animiertem Toggle:
      0 = Viele Accounts -> 1 Empf√§nger (StarGreeting alle 15 min)
      1 = Ein Account    -> Viele Empf√§nger (StarGreeting alle 15 min)
    """
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()

        # Gemeinsame States
        self.auto_running = False
        self.loop_thread  = None
        self.current_mode = 0  # 0 = MS->ST, 1 = SM->MT

        # --- Mode 0 (multi -> single) ---
        self.ms_accounts = []    # dicts mit access_token, username, password, country
        self.ms_token_refresh_thread = None

        # --- Mode 1 (single -> multi) ---
        self.sm_account   = None
        self.sm_targets   = []
        self.sm_token_refresh_thread = None

        self._build()
        self._start_token_refresh_threads()

    # ---------------- UI ----------------
    def _build(self):
        pad = 6

        # Modus-Umschalter (klein & animiert)
        mf = ttk.LabelFrame(self, text="Modus")
        mf.pack(fill="x", padx=pad, pady=(pad, 0))

        self.mode_label = ttk.Label(mf, text="Viele Accounts ‚Üí 1 Empf√§nger")
        self.mode_label.pack(side="right", padx=pad)

        # Wichtig: on_toggle ruft NUR _apply_mode (keine programmatic set-Calls!)
        def _on_toggle(is_on: bool):
            self._apply_mode(1 if is_on else 0)

        self.mode_switch = AnimatedToggleSwitch(mf, value=False, on_toggle=_on_toggle, width=44, height=24)
        self.mode_switch.pack(side="left", padx=pad, pady=(4, 4))

        # Container f√ºr beide Modi
        self.container = ttk.Frame(self)
        self.container.pack(fill="both", expand=True, padx=pad, pady=pad)

        # --------- Mode 0 UI  (Viele -> Ein) ---------
        self.frame_ms = ttk.Frame(self.container)

        lf = ttk.LabelFrame(self.frame_ms, text="Login (mehrere Accounts)")
        lf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.ms_e_user = ttk.Entry(lf); self.ms_e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.ms_e_pw = ttk.Entry(lf, show="*"); self.ms_e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.ms_e_cty = ttk.Entry(lf); self.ms_e_cty.insert(0, "DE")
        self.ms_e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.ms_login_click).grid(row=3, columnspan=2, pady=(pad, 0))

        # (ENTFERNT) ListeLogin-Buttons

        self.ms_list = tk.Listbox(self.frame_ms, height=5, bg="#000000", fg="white",
                                  selectbackground="#000000", selectforeground="white")
        self.ms_list.pack(fill="x", padx=pad, pady=(0, 2))

        ttk.Button(self.frame_ms, text="‚ùå Ausgew√§hlten Account entfernen", command=self.ms_remove_selected).pack(padx=pad, pady=(0, pad))

        tf = ttk.LabelFrame(self.frame_ms, text="Empf√§nger (Name oder profileId)")
        tf.pack(fill="x", padx=pad, pady=pad)
        self.ms_e_target = ttk.Entry(tf)
        self.ms_e_target.pack(fill="x", padx=pad, pady=(pad, 2))
        self.ms_var_target_is_id = tk.BooleanVar(value=False)
        ttk.Checkbutton(tf, text="Eingabe ist bereits profileId",
                        variable=self.ms_var_target_is_id).pack(anchor="w", padx=pad)

        ctl = ttk.Frame(self.frame_ms); ctl.pack(fill="x", padx=pad, pady=(pad, 0))
        ttk.Button(ctl, text="‚ñ∂Ô∏è Start (alle 15 Min.)", command=self.start_loop).pack(side="left")
        ttk.Button(ctl, text="‚èπÔ∏è Stop", command=self.stop_loop).pack(side="left", padx=(pad, 0))

        # --------- Mode 1 UI  (Ein -> Viele) ---------
        self.frame_sm = ttk.Frame(self.container)

        lfs = ttk.LabelFrame(self.frame_sm, text="Login (ein Account)")
        lfs.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(lfs, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.sm_e_user = ttk.Entry(lfs); self.sm_e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lfs, text="Passwort").grid(row=1, column=0, sticky="w")
        self.sm_e_pw = ttk.Entry(lfs, show="*"); self.sm_e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lfs, text="Land").grid(row=2, column=0, sticky="w")
        self.sm_e_cty = ttk.Entry(lfs); self.sm_e_cty.insert(0, "DE")
        self.sm_e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lfs, text="Anmelden", command=self.sm_login_click).grid(row=3, columnspan=2, pady=(pad, 0))

        tgtf = ttk.LabelFrame(self.frame_sm, text="Empf√§nger verwalten")
        tgtf.pack(fill="both", padx=pad, pady=pad)

        row = ttk.Frame(tgtf); row.pack(fill="x", padx=pad, pady=(pad, 2))
        ttk.Label(row, text="Empf√§nger (Name oder profileId):").pack(side="left")
        self.sm_e_add = ttk.Entry(row); self.sm_e_add.pack(side="left", fill="x", expand=True, padx=(6, 6))
        ttk.Button(row, text="‚ûï Hinzuf√ºgen", command=self.sm_add_target).pack(side="left")

        self.sm_listbox = tk.Listbox(tgtf, height=6, bg="#000000", fg="white",
                                     selectbackground="#333333", selectforeground="white")
        self.sm_listbox.pack(fill="both", expand=True, padx=pad, pady=(2, 2))

        row2 = ttk.Frame(tgtf); row2.pack(fill="x", padx=pad, pady=(0, pad))
        ttk.Button(row2, text="‚ùå Entfernen", command=self.sm_remove_selected).pack(side="left")
        ttk.Button(row2, text="üßπ Leeren", command=self.sm_clear_list).pack(side="left", padx=(pad, 0))
        self.sm_var_targets_are_ids = tk.BooleanVar(value=False)
        ttk.Checkbutton(tgtf, text="Alle Eintr√§ge sind bereits profileIds",
                        variable=self.sm_var_targets_are_ids).pack(anchor="w", padx=pad, pady=(0, 2))

        ctl2 = ttk.Frame(self.frame_sm); ctl2.pack(fill="x", padx=pad, pady=(pad, 0))
        ttk.Button(ctl2, text="‚ñ∂Ô∏è Start (alle 15 Min.)", command=self.start_loop).pack(side="left")
        ttk.Button(ctl2, text="‚èπÔ∏è Stop", command=self.stop_loop).pack(side="left", padx=(pad, 0))

        # --------- Log ----------
        self.log = ScrolledText(self, height=14, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

        # Initiale Ansicht NUR programmatisch setzen (Switch ohne Callback anpassen)
        self._switch_mode(0)

    # --------- Neue Trennung: Anwenden vs. Setzen ----------
    def _apply_mode(self, m: int):
        """Nur Frames/Label aktualisieren, KEIN set() auf dem Switch!"""
        self.current_mode = m
        for child in (self.frame_ms, self.frame_sm):
            child.pack_forget()
        if m == 0:
            self.frame_ms.pack(fill="both", expand=True)
            self.mode_label.config(text="Viele Accounts ‚Üí 1 Empf√§nger")
        else:
            self.frame_sm.pack(fill="both", expand=True)
            self.mode_label.config(text="Ein Account ‚Üí Viele Empf√§nger")

    def _switch_mode(self, m: int):
        """Programmatische Umschaltung: Switch-Status setzen OHNE on_toggle, danach UI anwenden."""
        self.mode_switch.set(m == 1, trigger=False)  # kein Callback feuern
        self._apply_mode(m)

    # ---------------- Helpers / (‚Ä¶ Rest bleibt wie gehabt) ----------------
    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        if int(self.log.index("end-1c").split(".")[0]) > 500:
            self.log.delete("1.0", "120.0")
        self.log.see(tk.END)

    def _looks_like_uuid(self, s: str) -> bool:
        s = s.strip().lower()
        return len(s) == 32 and all(c in "0123456789abcdef" for c in s)

    def _start_token_refresh_threads(self):
        def ms_refresh():
            while True:
                time.sleep(3600)
                for i, acc in enumerate(list(self.ms_accounts)):
                    try:
                        new_token = login(acc["username"], acc["password"], acc["country"])
                        new_token["username"] = acc["username"]
                        new_token["password"] = acc["password"]
                        new_token["country"]  = acc["country"]
                        self.ms_accounts[i] = new_token
                        self.write(f"[REFRESH] Token erneuert f√ºr {acc['username']}", "cyan")
                    except Exception as e:
                        self.write(f"[FEHLER] Token-Refresh (MS) {acc.get('username','?')}: {e}", "red")
        threading.Thread(target=ms_refresh, daemon=True).start()

        def sm_refresh():
            while True:
                time.sleep(3600)
                if not self.sm_account:
                    continue
                try:
                    acc = self.sm_account
                    new_token = login(acc["username"], acc["password"], acc["country"])
                    new_token["username"] = acc["username"]
                    new_token["password"] = acc["password"]
                    new_token["country"]  = acc["country"]
                    self.sm_account = new_token
                    self.write(f"[REFRESH] Token erneuert f√ºr {acc['username']}", "cyan")
                except Exception as e:
                    self.write(f"[FEHLER] Token-Refresh (SM): {e}", "red")
        threading.Thread(target=sm_refresh, daemon=True).start()

    # ---------------- Logins ----------------
    # Mode 0
    def ms_login_click(self):
        u = self.ms_e_user.get().strip()
        p = self.ms_e_pw.get().strip()
        c = self.ms_e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")
        try:
            acc = login(u, p, c)
            acc["username"] = u; acc["password"] = p; acc["country"] = c
            self.ms_accounts.append(acc)
            self.ms_list.insert(tk.END, u)
            self.write(f"[OK] Eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")

    def ms_login_from_file(self, filename):
        try:
            base_dir = os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__)
            full_path = os.path.join(base_dir, filename)
            self.write(f"[DEBUG] Lese Datei: {full_path}", "yellow")
            with open(full_path, "r", encoding="utf-8") as f:
                lines = f.readlines()
            added = 0
            for line in lines:
                parts = line.strip().split(":")
                if len(parts) < 2:
                    continue
                u = parts[0].strip()
                p = parts[1].strip()
                c = parts[2].strip().upper() if len(parts) > 2 else "DE"
                try:
                    acc = login(u, p, c)
                    acc["username"] = u; acc["password"] = p; acc["country"] = c
                    self.ms_accounts.append(acc)
                    self.ms_list.insert(tk.END, u)
                    added += 1
                except Exception as e:
                    self.write(f"[FEHLER] {u}: {e}", "red")
            self.write(f"[INFO] {added} Accounts geladen.", "cyan")
        except Exception as e:
            self.write(f"[FEHLER] Datei: {e}", "red")

    def ms_remove_selected(self):
        sel = self.ms_list.curselection()
        if not sel:
            return
        idx = sel[0]
        acc = self.ms_accounts[idx]
        self.ms_list.delete(idx)
        del self.ms_accounts[idx]
        self.write(f"[INFO] Account entfernt: {acc.get('username','?')}", "yellow")

    # Mode 1
    def sm_login_click(self):
        u = self.sm_e_user.get().strip()
        p = self.sm_e_pw.get().strip()
        c = self.sm_e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")
        try:
            acc = login(u, p, c)
            acc["username"] = u; acc["password"] = p; acc["country"] = c
            self.sm_account = acc
            self.write(f"[OK] Eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")

    # Empf√§nger-Management (Mode 1)
    def sm_add_target(self):
        val = self.sm_e_add.get().strip()
        if not val:
            return
        self.sm_listbox.insert(tk.END, val)
        self.sm_e_add.delete(0, tk.END)

    def sm_remove_selected(self):
        sel = self.sm_listbox.curselection()
        if not sel:
            return
        self.sm_listbox.delete(sel[0])

    def sm_clear_list(self):
        self.sm_listbox.delete(0, tk.END)

    # ---------------- API ----------------
    def find_profile_id(self, username, region):
        """
        Sucht die profileId √ºber edgerelationships.findProfiles.
        Verwendet self.token_info['access_token'] (wie von dir gew√ºnscht).
        """
        try:
            if not hasattr(self, "token_info") or not self.token_info or "access_token" not in self.token_info:
                self.write("[FEHLER] Kein Token f√ºr Profilsuche vorhanden (self.token_info fehlt).", "red")
                return None

            name = (username or "").strip()
            if not name:
                self.write("[FEHLER] Leerer Name f√ºr Profilsuche.", "red")
                return None

            url = "https://eu.mspapis.com/edgerelationships/graphql/graphql"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Content-Type": "application/json"
            }
            query = """
            query GetProfileSearch($region: String!, $startsWith: String!, $pageSize: Int, $currentPage: Int, $preferredGameId: String!) {
                findProfiles(region: $region, nameBeginsWith: $startsWith, pageSize: $pageSize, page: $currentPage) {
                    totalCount
                    nodes {
                        id
                        avatar(preferredGameId: $preferredGameId) {
                            gameId
                            face
                            full
                        }
                    }
                }
            }
            """
            variables = {
                "region": region,
                "startsWith": name,
                "pageSize": 50,
                "currentPage": 1,
                "preferredGameId": "j68d"
            }
            payload = {"query": query, "variables": variables}

            r = self.scraper.post(url, headers=headers, json=payload, timeout=15)
            r.raise_for_status()
            data = r.json()
            nodes = data.get("data", {}).get("findProfiles", {}).get("nodes", [])
            if not nodes:
                self.write(f"[FEHLER] Kein Profil mit dem Namen '{name}' gefunden.", "red")
                return None
            return nodes[0]["id"]
        except Exception as e:
            self.write(f"[FEHLER] Profil-ID konnte nicht ermittelt werden: {e}", "red")
            return None

    def send_star_greeting(self, access_token, receiver_profile_id, label):
        try:
            url = "https://eu.mspapis.com/federationgateway/graphql"
            headers = {"Authorization": f"Bearer {access_token}", "Content-Type": "application/json"}
            payload = {
                "id": "SendGreetings-159BDD7706D824BB8F14874A7FAE3368",
                "variables": {
                    "greetingType": "StarGreeting",
                    "receiverProfileId": receiver_profile_id,
                    "ignoreDailyCap": False
                }
            }
            r = self.scraper.post(url, headers=headers, json=payload, timeout=12)
            r.raise_for_status()
            data = r.json()
            success = (
                data.get("data", {}).get("greetings", {}).get("sendGreeting", {}).get("success", False)
            ) or (
                data.get("data", {}).get("sendGreeting", {}).get("success", False)
            )
            if success:
                self.write(f"[OK] StarGreeting ‚Üí {label}", "green")
            else:
                self.write(f"[FEHLER] StarGreeting ‚Üí {label} fehlgeschlagen.", "red")
        except Exception as e:
            self.write(f"[FEHLER] StarGreeting ‚Üí {label}: {e}", "red")

    # ---------------- Loop Control ----------------
    def start_loop(self):
        if self.auto_running:
            return self.write("[INFO] L√§uft bereits.", "yellow")

        m = self.current_mode
        if m == 0:
            # MS ‚Üí ST
            if not self.ms_accounts:
                return messagebox.showwarning("Fehler", "Bitte mindestens einen Account einloggen.")
            if not self.ms_e_target.get().strip():
                return messagebox.showwarning("Fehler", "Empf√§nger angeben!")
        else:
            # SM ‚Üí MT
            if not self.sm_account:
                return messagebox.showwarning("Fehler", "Bitte zuerst einloggen!")
            if self.sm_listbox.size() == 0:
                return messagebox.showwarning("Fehler", "Keine Empf√§nger in der Liste!")

        self.auto_running = True
        self.loop_thread = threading.Thread(target=self._loop, daemon=True)
        self.loop_thread.start()
        self.write("[INFO] Auto-Run gestartet (Intervall 15 Min.)", "cyan")

    def stop_loop(self):
        self.auto_running = False
        self.write("[INFO] Gestoppt.", "yellow")

    def _loop(self):
        INTERVAL = 15 * 60  # 15 Minuten
        while self.auto_running:
            mode_now = self.current_mode
            try:
                if mode_now == 0:
                    self._run_mode_ms()
                else:
                    self._run_mode_sm()
            except Exception as e:
                self.write(f"[FEHLER] Run: {e}", "red")

            # Warten bis n√§chste Runde
            if not self.auto_running:
                break
            for remain in range(INTERVAL, 0, -1):
                if not self.auto_running:
                    break
                if remain % 30 == 0 or remain <= 10:
                    self.write(f"[WARTEN] N√§chste Runde in {remain}s ...", "cyan")
                time.sleep(1)

        self.write("[INFO] Auto-Run beendet.", "yellow")

    # --- Runde: Mode 0 (Viele -> Ein) ---
    def _run_mode_ms(self):
        target_raw = self.ms_e_target.get().strip()
        treat_as_id = self.ms_var_target_is_id.get()
        if not target_raw:
            self.write("[FEHLER] Kein Empf√§nger gesetzt.", "red")
            return

        # Ziel-ID aufl√∂sen (einmalig)
        first_acc = self.ms_accounts[0]
        region = first_acc.get("country", "DE").upper()
        # WICHTIG: Tokenquelle setzen, damit find_profile_id darauf zugreift
        self.token_info = first_acc

        if treat_as_id or self._looks_like_uuid(target_raw) or "|" in target_raw:
            receiver_id = target_raw
            label = target_raw
        else:
            receiver_id = self.find_profile_id(target_raw, region)
            if not receiver_id:
                return
            label = f"{target_raw} ({receiver_id})"

        # Jeder Account sendet 1x
        for acc in list(self.ms_accounts):
            if not self.auto_running:
                break
            self.send_star_greeting(acc["access_token"], receiver_id, f"{label} ‚Üê {acc.get('username','?')}")
            time.sleep(1)

    # --- Runde: Mode 1 (Ein -> Viele) ---
    def _run_mode_sm(self):
        acc = self.sm_account
        region = acc.get("country", "DE").upper()
        # WICHTIG: Tokenquelle setzen
        self.token_info = acc

        entries = [self.sm_listbox.get(i) for i in range(self.sm_listbox.size())]
        treat_as_ids = self.sm_var_targets_are_ids.get()
        if not entries:
            self.write("[INFO] Keine Empf√§nger vorhanden.", "yellow")
            return

        for item in list(entries):
            if not self.auto_running:
                break

            if treat_as_ids or self._looks_like_uuid(item) or "|" in item:
                receiver_id = item
                label = item
            else:
                receiver_id = self.find_profile_id(item.strip(), region)
                if not receiver_id:
                    continue
                label = f"{item} ({receiver_id})"

            self.send_star_greeting(acc["access_token"], receiver_id, label)
            time.sleep(1)


class SpecialMassSenderTab(ttk.Frame):
    """
    Zwei Logins (jeweils doppelt), Ziel (Name oder profileId) eingeben,
    Greeting-Typ w√§hlen und 'N' parallele Anfragen *pro Account* abfeuern.
    Buttons: Threads vorbereiten -> gemeinsamer Start -> Stop.
    """
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.accounts = []            # Liste von token_info Dicts (je Login 2x)
        self.threads = []
        self.start_event = threading.Event()
        self.running = False
        self.token_info = None        # wird f√ºr find_profile_id verwendet (siehe Wunsch)
        self._build()

    # ---------- UI ----------
    def _build(self):
        pad = 6

        lf = ttk.LabelFrame(self, text="Logins einzeln (jeder wird doppelt eingeloggt)")
        lf.pack(fill="x", padx=pad, pady=pad)

        for i in range(2):
            ttk.Label(lf, text=f"Benutzer {i+1}").grid(row=i*4, column=0, sticky="w")
            setattr(self, f"e_user{i}", ttk.Entry(lf))
            getattr(self, f"e_user{i}").grid(row=i*4, column=1, padx=pad)

            ttk.Label(lf, text="Passwort").grid(row=i*4+1, column=0, sticky="w")
            setattr(self, f"e_pw{i}", ttk.Entry(lf, show="*"))
            getattr(self, f"e_pw{i}").grid(row=i*4+1, column=1, padx=pad)

            ttk.Label(lf, text="Land").grid(row=i*4+2, column=0, sticky="w")
            e_cty = ttk.Entry(lf); e_cty.insert(0, "DE")
            setattr(self, f"e_cty{i}", e_cty)
            e_cty.grid(row=i*4+2, column=1, padx=pad)

            ttk.Button(lf, text=f"Login Benutzer {i+1}",
                       command=lambda idx=i: self.login_click(idx)).grid(row=i*4+3, columnspan=2, pady=pad)

        tf = ttk.LabelFrame(self, text="üéØ Ziel & Einstellungen")
        tf.pack(fill="x", padx=pad, pady=pad)

        ttk.Label(tf, text="Ziel (Name oder profileId):").grid(row=0, column=0, sticky="w")
        self.e_target = ttk.Entry(tf); self.e_target.grid(row=0, column=1, sticky="ew", padx=pad)
        tf.columnconfigure(1, weight=1)

        self.var_is_id = tk.BooleanVar(value=False)
        ttk.Checkbutton(tf, text="Eingabe ist bereits profileId",
                        variable=self.var_is_id).grid(row=1, column=1, sticky="w", padx=pad, pady=(0, 4))

        ttk.Label(tf, text="Greeting-Typ:").grid(row=2, column=0, sticky="w")
        self.greeting_var = tk.StringVar(value="StarGreeting")
        ttk.Combobox(tf, textvariable=self.greeting_var,
                     values=["StarGreeting", "Autograph"],
                     state="readonly", width=18).grid(row=2, column=1, sticky="w", padx=pad, pady=(0, 4))

        ttk.Label(tf, text="Parallele Anfragen pro Account:").grid(row=3, column=0, sticky="w")
        self.per_acc_threads = tk.IntVar(value=20)
        ttk.Spinbox(tf, from_=1, to=200, textvariable=self.per_acc_threads, width=6)\
           .grid(row=3, column=1, sticky="w", padx=pad)

        ttk.Button(self, text="üß† Threads vorbereiten", command=self.prepare_threads).pack(pady=pad)
        ttk.Button(self, text="üéØ Jetzt starten", command=self.start_event.set).pack(pady=(0, pad))
        ttk.Button(self, text="‚èπÔ∏è Stop", command=self.stop).pack(pady=(0, pad))

        self.log = ScrolledText(self, height=12, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    # ---------- Login ----------
    def login_click(self, idx: int):
        u = getattr(self, f"e_user{idx}").get().strip()
        p = getattr(self, f"e_pw{idx}").get().strip()
        c = getattr(self, f"e_cty{idx}").get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")

        try:
            for _ in range(2):  # doppelt einloggen (wie gew√ºnscht)
                token_info = login(u, p, c)
                token_info["username"] = u
                token_info["country"]  = c
                self.accounts.append(token_info)
            self.write(f"[OK] Benutzer {idx+1} doppelt eingeloggt: {u}", "green")
        except Exception as e:
            self.write(f"[FEHLER] Login Benutzer {idx+1}: {e}", "red")
            messagebox.showerror("Login", str(e))

    # ---------- Threads vorbereiten ----------
    def prepare_threads(self):
        if not self.accounts:
            return messagebox.showwarning("Fehler", "Bitte mindestens einen Benutzer einloggen.")

        target_raw = (self.e_target.get() or "").strip()
        if not target_raw:
            return messagebox.showwarning("Fehler", "Bitte Ziel eingeben.")

        # F√ºr die gew√ºnschte find_profile_id verwenden wir self.token_info (= erster Account)
        self.token_info = self.accounts[0]
        region = self.token_info.get("country", "DE").upper()

        if self.var_is_id.get() or self._looks_like_uuid(target_raw) or "|" in target_raw:
            receiver_id = target_raw
            label = target_raw
        else:
            receiver_id = self.find_profile_id(target_raw, region)  # *** exakt nach deiner Vorlage ***
            if not receiver_id:
                return
            label = f"{target_raw} ({receiver_id})"

        self.threads.clear()
        self.start_event.clear()
        self.running = True

        per_acc = max(1, int(self.per_acc_threads.get()))
        greeting_type = self.greeting_var.get()

        for acc in self.accounts:
            token = acc["access_token"]
            for _ in range(per_acc):
                t = threading.Thread(
                    target=self._worker_send_once,
                    args=(token, receiver_id, greeting_type, f"{label} ‚Üê {acc.get('username','?')}"),
                    daemon=True
                )
                self.threads.append(t)

        for t in self.threads:
            t.start()

        self.write(f"[INFO] {len(self.accounts)} Accounts √ó {per_acc} Threads vorbereitet "
                   f"(gesamt {len(self.threads)}). Klicke jetzt auf 'üéØ Jetzt starten'.", "cyan")

    def _worker_send_once(self, token, receiver_id, greeting_type, label):
        self.start_event.wait()   # Synchronstart
        if not self.running:
            return
        self._send_greeting_once(token, receiver_id, greeting_type, label)

    def stop(self):
        self.running = False
        self.start_event.set()
        self.write("[INFO] gestoppt.", "yellow")

    # ---------- Request ----------
    def _send_greeting_once(self, access_token, receiver_profile_id, greeting_type, label):
        try:
            url = "https://eu.mspapis.com/federationgateway/graphql"
            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json",
                "Referer": "https://moviestarplanet2.com/",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36"
            }
            payload = {
                "id": "SendGreetings-159BDD7706D824BB8F14874A7FAE3368",
                "variables": {
                    "greetingType": greeting_type,   # "StarGreeting" oder "Autograph"
                    "receiverProfileId": receiver_profile_id,
                    "ignoreDailyCap": False
                }
            }
            res = self.scraper.post(url, headers=headers, json=payload, timeout=8)
            res.raise_for_status()
            data = res.json()
            success = (
                data.get("data", {}).get("greetings", {}).get("sendGreeting", {}).get("success", False)
            ) or (
                data.get("data", {}).get("sendGreeting", {}).get("success", False)
            )
            if success:
                self.after(0, self.write, f"[OK] {greeting_type} ‚Üí {label}", "green")
            else:
                self.after(0, self.write, f"[FEHLER] {greeting_type} ‚Üí {label} fehlgeschlagen.", "red")
        except Exception as e:
            self.after(0, self.write, f"[FEHLER] {greeting_type} ‚Üí {label}: {e}", "red")

    # ---------- Utils ----------
    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

    def _looks_like_uuid(self, s: str) -> bool:
        s = (s or "").strip().lower()
        return len(s) == 32 and all(c in "0123456789abcdef" for c in s)

    # *** exakt DEINE gew√ºnschte find_profile_id ‚Äì unver√§ndert √ºbernommen ***
    def find_profile_id(self, username, region):
        try:
            url = "https://eu.mspapis.com/edgerelationships/graphql/graphql"
            headers = {
                "Authorization": f"Bearer {self.token_info['access_token']}",
                "Content-Type": "application/json"
            }
            query = """
            query GetProfileSearch($region: String!, $startsWith: String!, $pageSize: Int, $currentPage: Int, $preferredGameId: String!) {
                findProfiles(region: $region, nameBeginsWith: $startsWith, pageSize: $pageSize, page: $currentPage) {
                    totalCount
                    nodes {
                        id
                        avatar(preferredGameId: $preferredGameId) {
                            gameId
                            face
                            full
                        }
                    }
                }
            }
            """
            variables = {
                "region": region,
                "startsWith": username,
                "pageSize": 50,
                "currentPage": 1,
                "preferredGameId": "j68d"
            }
            payload = {"query": query, "variables": variables}
            r = self.scraper.post(url, headers=headers, json=payload)
            r.raise_for_status()
            data = r.json()
            nodes = data.get("data", {}).get("findProfiles", {}).get("nodes", [])
            if not nodes:
                self.write(f"[FEHLER] Kein Profil mit dem Namen '{username}' gefunden.", "red")
                return None
            return nodes[0]["id"]
        except Exception as e:
            self.write(f"[FEHLER] Profil-ID konnte nicht ermittelt werden: {e}", "red")
            return None
        
# -------------------- Password Change Tab --------------------
# -------------------- Password Change Tab (Identity-Bearer direkt) --------------------
class PasswordChangeTab(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.scraper = cloudscraper.create_scraper()
        self.token_info = None
        self.identity_access_token = None
        self.identity_claims = {}
        self.country = "DE"
        self.game_id = "j68d"
        self.display_name = ""
        self._build()

    def _build(self):
        pad = 6
        lf = ttk.LabelFrame(self, text="Login"); lf.pack(fill="x", padx=pad, pady=pad)
        ttk.Label(lf, text="Benutzername").grid(row=0, column=0, sticky="w")
        self.e_user = ttk.Entry(lf); self.e_user.grid(row=0, column=1, padx=pad)

        ttk.Label(lf, text="Passwort").grid(row=1, column=0, sticky="w")
        self.e_pw = ttk.Entry(lf, show="*"); self.e_pw.grid(row=1, column=1, padx=pad)

        ttk.Label(lf, text="Land").grid(row=2, column=0, sticky="w")
        self.e_cty = ttk.Entry(lf); self.e_cty.insert(0, "DE"); self.e_cty.grid(row=2, column=1, padx=pad)

        ttk.Button(lf, text="Anmelden", command=self.login_click).grid(row=3, columnspan=2, pady=pad)

        cf = ttk.LabelFrame(self, text="Passwort √§ndern"); cf.pack(fill="x", padx=pad, pady=pad)
        ttk.Label(cf, text="Neues Passwort").grid(row=0, column=0, sticky="w")
        self.e_new_pw = ttk.Entry(cf, show="*"); self.e_new_pw.grid(row=0, column=1, padx=pad)

        ttk.Button(self, text="√Ñndern", command=self.change_password_click).pack(pady=(0, pad))

        self.claim_text = tk.StringVar()
        ttk.Label(self, textvariable=self.claim_text, justify="left").pack(pady=(0, pad))

        self.log = ScrolledText(self, height=12, bg="#000000", fg="#ffffff", insertbackground="white")
        self.log.pack(fill="both", expand=True, padx=pad, pady=pad)

    def write(self, msg, col=None):
        tag = None
        if col:
            self.log.tag_config(col, foreground=col)
            tag = col
        self.log.insert(tk.END, msg + "\n", tag)
        self.log.see(tk.END)

    def _looks_like_guid(self, s: str) -> bool:
        s = (s or "").strip()
        return len(s) == 32 and all(c in "0123456789abcdef" for c in s.lower())

    def _jwt_payload(self, jwt_token: str) -> dict:
        try:
            parts = jwt_token.split(".")
            if len(parts) < 2:
                return {}
            import base64, json
            pad_len = (-len(parts[1]) % 4)
            payload = base64.urlsafe_b64decode(parts[1] + ("=" * pad_len))
            return json.loads(payload.decode("utf-8", errors="ignore"))
        except Exception:
            return {}

    def login_click(self):
        u = self.e_user.get().strip()
        p = self.e_pw.get().strip()
        c = self.e_cty.get().strip().upper()
        if not all([u, p, c]):
            return messagebox.showwarning("Fehler", "Alle Felder ausf√ºllen!")
        self.country = c
        try:
            acc = login(u, p, c)
            acc["username"] = u
            acc["password"] = p
            acc["country"] = c
            self.token_info = acc
            self.display_name = acc.get("username", u)
            self.write(f"[OK] Eingeloggt als {u}", "green")

            at = self.token_info.get("access_token", "")
            claims = self._jwt_payload(at)
            if at:
                self.identity_access_token = acc.get("access_token", "")
                self.identity_claims = self._jwt_payload(self.identity_access_token)
                self.write("[OK] Identity-Access-Token √ºbernommen.", "green")

                # Zeige Claims
                pretty = "\n".join([f"{k}: {v}" for k, v in self.identity_claims.items()])
                self.claim_text.set(f"üîê JWT Claims:\n{pretty}")
            else:
                self.write("[WARN] Identity-Token fehlte ‚Äì GraphQL wird fehlschlagen.", "yellow")

        except Exception as e:
            self.write(f"[FEHLER] Login: {e}", "red")
            messagebox.showerror("Login", str(e))


    def change_password_click(self):
        if not self.token_info:
            return messagebox.showwarning("Nicht eingeloggt", "Bitte zuerst einloggen.")
        if not self.identity_access_token:
            self.write("[FEHLER] Identity-Token fehlt ‚Äì Passwort √§ndern nicht m√∂glich.", "red")
            return

        new_pw = self.e_new_pw.get().strip()
        if not new_pw:
            return messagebox.showwarning("Fehler", "Neues Passwort eingeben.")

        login_id = self.identity_claims.get("loginId") or self.identity_claims.get("sub") or ""
        if not login_id:
            self.write("[FEHLER] Konnte loginId nicht aus Identity-Token lesen.", "red")
            return

        profile_id = self.token_info.get("profile_id", "")
        if not profile_id:
            self.write("[FEHLER] profile_id fehlt aus Game-Login.", "red")
            return

        name = self.display_name or self.token_info.get("username", "")

        try:
            ok = self._change_password_edgelogins(
                bearer=self.identity_access_token,
                login_id=login_id,
                profile_id=profile_id,
                game_id=self.game_id,
                name=name,
                current_password=self.token_info.get("password", ""),
                new_password=new_pw,
                is_guest=False
            )
            if ok:
                self.write("[OK] Passwort erfolgreich ge√§ndert.", "green")
            else:
                self.write("[FEHLER] Passwort √§ndern fehlgeschlagen (siehe Log).", "red")
        except Exception as e:
            self.write(f"[FEHLER] Passwort √§ndern: {e}", "red")

    def _change_password_edgelogins(self, bearer: str, login_id: str, profile_id: str,
                                    game_id: str, name: str,
                                    current_password: str, new_password: str,
                                    is_guest: bool = False) -> bool:
        """
        F√ºhrt die GraphQL-Mutation auf edgelogins mit DEM Identity-Bearer aus.
        """
        url = "https://edgelogins.eu.moviestarplanet.app/graphql"
        headers = {
            "Authorization": f"Bearer {bearer}",
            "Content-Type": "application/json",
            "Referer": "https://moviestarplanet2.com/",
            "User-Agent": "Mozilla/5.0",
            "sec-ch-ua": "\"Opera GX\";v=\"120\", \"Not-A.Brand\";v=\"8\", \"Chromium\";v=\"135\"",
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "\"Windows\"",
        }

        query = (
            "mutation UpdateLogin($loginId: String!, $profileId: String!, $gameId: String!, $name: String, "
            "$currentPassword: String!, $newPassword: String!, $isGuest: Boolean){"
            "updateLoginProfile(input: { loginId: $loginId, profileId: $profileId, gameId: $gameId, name: $name, "
            "passwords: { currentPassword: $currentPassword, newPassword: $newPassword}, isGuest: $isGuest}) "
            "{success,loginProfile {loginId,loginName,profileId,profileName,isGuest},error}}"
        )

        variables = {
            "loginId": login_id,
            "profileId": profile_id,
            "gameId": game_id,
            "name": name,
            "currentPassword": current_password,
            "newPassword": new_password,
            "isGuest": bool(is_guest),
        }

        # WICHTIG: variables NICHT als String √ºbergeben!
        payload = {"query": query, "variables": variables}

        try:
            self.write(f"[DEBUG] GraphQL Variables:\n{json.dumps(variables, indent=2)}", "yellow")
            r = self.scraper.post(url, headers=headers, json=payload, timeout=20)
            r.raise_for_status()
            js = r.json()

            if "errors" in js and js["errors"]:
                self.write(f"[FEHLER] GraphQL-Errors: {js['errors']}", "red")
                return False

            data = js.get("data", {}).get("updateLoginProfile", {})
            if not data:
                self.write(f"[FEHLER] Unerwartete Antwort: {js}", "red")
                return False

            if data.get("success") is True:
                lp = data.get("loginProfile") or {}
                self.write(f"[OK] √Ñnderung best√§tigt: {lp.get('loginName')} / {lp.get('profileName')}", "green")
                return True

            self.write(f"[FEHLER] √Ñnderung fehlgeschlagen: {data.get('error')}", "red")
            return False

        except Exception as e:
            self.write(f"[FEHLER] HTTP: {e}", "red")
            return False


# -------------------- Main Window --------------------
class MSP2Toolkit(tk.Tk):
    def __init__(self):
        super().__init__()
        self.iconbitmap(resource_path("rabbit.ico"))
        setup_style(self)
        self.title("NiveDev v2.0")
        self.geometry("740x770")

        # Logo
        img = Image.open(resource_path("rabbit.jpg"))
        img = img.resize((60, 60), Image.LANCZOS)
        self.logo_img = ImageTk.PhotoImage(img)
        ttk.Label(self, image=self.logo_img, anchor="center").pack(pady=(10, 0))

        # Hauptcontainer
        self.wrapper = ttk.Frame(self)
        self.wrapper.pack(fill="both", expand=True)

        # Notebook ‚Äì versteckt Tabs mit "tabposition"
        self.nb = ttk.Notebook(self.wrapper)
        self.nb.enable_traversal()
        self.nb.pack_forget()

        # Tools initialisieren
        self.tabs = {}
        self.tool_configs = [
            ("LoveIt", LoveItTab),
            ("Token", TokenRunnerTab),
            ("Gender", GenderSwitchTab),
            ("Autos", AutographTab),
            ("Dupli", GiftOpenerTab),
            ("Daily", DailyLogin),
            ("Teleport", TeleportTab),
            ("DFW", StarGreetingComboTab),
            ("Passwort", PasswordChangeTab),
        ]

        for name, TabClass in self.tool_configs:
            frame = ttk.Frame(self.nb)
            tab = TabClass(frame)

            # BACK Button hinzuf√ºgen
            back_btn = ttk.Button(frame, text="‚¨ÖÔ∏è Back", command=self.back_to_menu)
            back_btn.pack(anchor="w", padx=10, pady=10)
            tab.pack(fill="both", expand=True)
            self.nb.add(frame, text=name)
            self.tabs[name] = frame

        # Men√º anzeigen
        self.menu_frame = ttk.Frame(self.wrapper)
        self.menu_frame.pack(pady=10)
        self.create_tool_buttons()

    def create_tool_buttons(self):
        for i, (name, _) in enumerate(self.tool_configs):
            btn = tk.Button(
                self.menu_frame,
                text=name,
                command=lambda i=i: self.select_tab(i),
                font=("Comic Sans MS", 10, "bold"),
                bg="#941515",
                fg="white",
                relief="flat",
                padx=14,
                pady=10,
                bd=0,
                cursor="hand2",
                width=10,
                height=2,
            )
            btn.pack(side="left", padx=8, pady=8)

    def select_tab(self, index: int):
        self.menu_frame.pack_forget()
        self.nb.pack(fill="both", expand=True, padx=6, pady=6)
        self.nb.select(index)

    def back_to_menu(self):
        self.nb.pack_forget()
        self.menu_frame.pack(pady=10)

if __name__ == "__main__":
    MSP2Toolkit().mainloop()
